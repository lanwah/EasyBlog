# [异步编程模式(Asynchronous programming patterns)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/)

[TOC]

---

.NET 提供了执行异步操作的三种模式：

- **基于任务的异步模式 (TAP)** ，该模式使用单一方法表示异步操作的开始和完成。 TAP 是在 .NET Framework 4 中引入的。 **这是在 .NET 中进行异步编程的推荐方法。** C# 中的 [async](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/async) 和 [await](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/await) 关键词以及 Visual Basic 中的 [Async](https://learn.microsoft.com/zh-cn/dotnet/visual-basic/language-reference/modifiers/async) 和 [Await](https://learn.microsoft.com/zh-cn/dotnet/visual-basic/language-reference/operators/await-operator) 运算符为 TAP 添加了语言支持。 有关详细信息，请参阅[基于任务的异步模式 (TAP)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)。
- [**基于事件的异步模式 (EAP)**](#基于事件的异步模式 (EAP))，是提供异步行为的基于事件的旧模型。 这种模式需要后缀为 `Async` 的方法，以及一个或多个事件、事件处理程序委托类型和 `EventArg` 派生类型。 EAP 是在 .NET Framework 2.0 中引入的。 建议新开发中不再使用这种模式。 有关详细信息，请参阅[基于事件的异步模式 (EAP)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap)。
- [**异步编程模型 (APM) 模式**](#异步编程模型 (APM))（也称为 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式），这是使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 接口提供异步行为的旧模型。 在这种模式下，同步操作需要 `Begin` 和 `End` 方法（例如，`BeginWrite` 和 `EndWrite`以实现异步写入操作）。 不建议新的开发使用此模式。 有关详细信息，请参阅[异步编程模型 (APM)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm)。

## 模式的比较

为了快速比较这三种模式的异步操作方式，请考虑使用从指定偏移量处起将指定量数据读取到提供的缓冲区中的`Read`方法：

```C#
public class MyClass  
{  
    public int Read(byte [] buffer, int offset, int count);  
}
```

此方法对应的 TAP 将公开以下单个 `ReadAsync` 方法：

```C#
public class MyClass  
{  
    public Task<int> ReadAsync(byte [] buffer, int offset, int count);  
}
```

对应的 EAP 将公开以下类型和成员的集：

```C#
public class MyClass  
{  
    public void ReadAsync(byte [] buffer, int offset, int count);  
    public event ReadCompletedEventHandler ReadCompleted;  
}
```

对应的 APM 将公开 `BeginRead` 和 `EndRead` 方法：

```C#
public class MyClass  
{  
    public IAsyncResult BeginRead(  
        byte [] buffer, int offset, int count,
        AsyncCallback callback, object state);  
    public int EndRead(IAsyncResult asyncResult);  
}
```

## 请参阅

- [异步编程模式 | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/)



# 异步编程模型 (APM)

[Asynchronous Programming Model (APM)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm)

## 概述

使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 设计模式的异步操作是通过名为 `BeginOperationName` 和 `EndOperationName` 的两个方法来实现的，这两个方法分别开始和结束异步操作 OperationName。 例如， [FileStream](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.filestream) 类提供 [BeginRead](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.filestream.beginread) 和 [EndRead](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.filestream.endread) 方法来从文件异步读取字节。 这两个方法实现了 [Read](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.filestream.read) 方法的异步版本。

> [!NOTE]
> 从 .NET Framework 4 开始，任务并行库为异步和并行编程提供了一种新模型。 有关详细信息，请参阅 “[任务并行库 (TPL)](https://learn.microsoft.com/zh-cn/dotnet/standard/parallel-programming/task-parallel-library-tpl)” 和 “[基于任务的异步模式 (TAP)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)”。

在调用 `BeginOperationName` 后，应用程序可以继续在调用线程上执行指令，同时异步操作在另一个线程上执行。 每次调用 `BeginOperationName` 时，应用程序还应调用 `EndOperationName` 来获取操作的结果。

### 开始异步操作

`BeginOperationName` 方法开始异步操作 OperationName，并返回实现 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 接口的对象。 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 对象存储有关异步操作的信息。 下表显示有关异步操作的信息。

| 成员                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [AsyncState](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncstate) | 一个特定于应用程序的可选对象，其中包含有关异步操作的信息。   |
| [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) | 一个 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) ，可用来在异步操作完成之前阻止应用程序执行。 |
| [CompletedSynchronously](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.completedsynchronously) | 一个值，指示异步操作是否是在用于调用 `BeginOperationName` 的线程上完成，而不是在单独的 [ThreadPool](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 线程上完成。 |
| [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted) | 一个值，指示异步操作是否已完成。                             |

`BeginOperationName` 方法采用该方法的同步版本的签名中声明的任何参数（由值传递或由引用传递）。 `BeginOperationName` 方法签名中不包含任何输出参数。 `BeginOperationName` 方法签名另外还包括两个其他参数。 第一个参数定义一个 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托，此委托引用在异步操作完成时调用的方法。 如果调用方不希望在操作完成后调用方法，它可以指定 `null` （在 Visual Basic 中为`Nothing` ）。 第二个参数是一个用户定义的对象。 此对象可用来向异步操作完成时调用的方法传递应用程序特定的状态信息。 如果 `BeginOperationName` 方法还采用其他一些操作特定的参数（例如，一个用于存储从文件读取的字节的字节数组），则 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 和应用程序状态对象将是 `BeginOperationName` 方法签名中的最后两个参数。

`BeginOperationName` 立即返回对调用线程的控制。 如果 `BeginOperationName` 方法引发异常，则会在开始异步操作之前引发异常。 如果 `BeginOperationName` 方法引发异常，则意味着没有调用回调方法。

### 结束异步操作

`EndOperationName` 方法用于结束异步操作 OperationName。 `EndOperationName` 方法的返回值与其同步对应方法的返回值类型相同，并且是特定于异步操作的。 例如， [EndRead](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.filestream.endread) 方法返回从 [FileStream](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.filestream) 读取的字节数， [EndGetHostByName](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns.endgethostbyname) 方法返回包含有关主机的信息的 [IPHostEntry](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.iphostentry) 对象。 `EndOperationName` 方法采用该方法同步版本的签名中声明的所有输出参数或引用参数。 除了来自同步方法的参数外，`EndOperationName` 方法还包括 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 参数。 调用方必须将对应调用返回的实例传递给 `BeginOperationName`。

如果调用 `EndOperationName` 时 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 对象表示的异步操作尚未完成，则 `EndOperationName` 将在异步操作完成之前阻止调用线程。 异步操作引发的异常是从 `EndOperationName` 方法引发的。 未定义多次使用同一 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 调用 `EndOperationName` 方法的效果。 同样，也未定义使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult)（相关 Begin 方法未返回）调用 `EndOperationName` 方法的效果。

> [!NOTE]
> 对于这两种未定义的情况，实施者应考虑引发 [InvalidOperationException](https://learn.microsoft.com/zh-cn/dotnet/api/system.invalidoperationexception)。

> [!NOTE]
> 此设计模式的实施者应通知调用方异步操作已通过以下步骤完成：将 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted) 设置为 true，调用异步回调方法（如果已指定一个回调方法），然后发送 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle)信号。

对于访问异步操作的结果，应用程序开发人员有若干种设计选择。 正确的选择取决于应用程序是否有可以在操作完成时执行的指令。 如果应用程序在接收到异步操作结果之前不能进行任何其他工作，则必须在获得这些结果之前先阻止该应用程序进行其他工作。 若要在异步操作完成之前阻止应用程序，可以使用下列方法之一：

- 从应用程序的主线程调用 `EndOperationName`，阻止应用程序执行，直到操作完成之后再继续执行。 有关展示了此方法的示例，请参阅[通过结束异步操作阻止应用执行](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/blocking-application-execution-by-ending-an-async-operation)。
- 使用 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 来阻止应用程序执行，直到一个或多个操作完成。 有关演示此方法的示例，请参阅 “[使用 AsyncWaitHandle 阻止应用程序的执行](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/blocking-application-execution-using-an-asyncwaithandle)”。

在异步操作完成时不需要阻止的应用程序可使用下列方法之一：

- 按以下方式轮询操作完成状态：定期检查 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted) 属性，操作完成后调用 `EndOperationName`。 有关演示此方法的示例，请参阅 [轮询异步操作的状态](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/polling-for-the-status-of-an-asynchronous-operation)。
- 使用 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托来指定要在操作完成时调用的方法。 有关演示此方法的示例，请参阅 [使用 AsyncCallback 委托结束异步操作](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/using-an-asynccallback-delegate-to-end-an-asynchronous-operation)。

### 请参考

- [异步编程模型 (APM) - .NET | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm)



## 使用 IAsyncResult 调用异步方法

.NET 库和第三方类库中的类型可以提供方法，以便应用程序能够继续执行，同时在除主应用程序线程外的线程中执行异步操作。 下面各部分介绍并提供了代码示例，展示了可以调用使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 设计模式的异步方法的不同方式。

- [通过结束异步操作阻止应用执行](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/blocking-application-execution-by-ending-an-async-operation)。
- [使用 AsyncWaitHandle 阻止应用执行](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/blocking-application-execution-using-an-asyncwaithandle)。
- [轮询异步操作状态](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/polling-for-the-status-of-an-asynchronous-operation)。
- [使用 AsyncCallback 委托结束异步操作](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/using-an-asynccallback-delegate-to-end-an-asynchronous-operation)。

### 通过结束异步操作来阻止应用程序执行

如果应用无法在等待异步操作结果期间继续执行其他工作，必须阻止应用一直到操作完成。 请使用下列方法之一，在应用等待异步操作完成期间阻止应用的主线程：

- 调用异步操作的 EndOperationName 方法。 本主题介绍的就是这种方法。
- 使用异步操作的 BeginOperationName 方法返回的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 的 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 属性。 有关展示这种方法的示例，请参阅[使用 AsyncWaitHandle 阻止应用执行](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/blocking-application-execution-using-an-asyncwaithandle)。

在异步操作完成前使用 End*OperationName 方法阻止的应用程序，通常会调用 Begin\*OperationName 方法，执行任何不需要等待操作结果也可以执行的工作，然后调用 End\*OperationName***。

#### 示例

下面的代码示例展示了如何使用 [Dns](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns) 类中的异步方法，检索用户指定计算机的域名系统信息。 请注意，对 [BeginGetHostByName](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns.begingethostbyname)`requestCallback` 和 `stateObject` 参数传递的是 `null`（Visual Basic 中的 `Nothing`），因为使用这种方法时这些是可选参数。

```C#
/*
The following example demonstrates using asynchronous methods to
get Domain Name System information for the specified host computer.
*/

using System;
using System.Net;
using System.Net.Sockets;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class BlockUntilOperationCompletes
    {
        public static void Main(string[] args)
        {
            // Make sure the caller supplied a host name.
            if (args.Length == 0 || args[0].Length == 0)
            {
                // Print a message and exit.
                Console.WriteLine("You must specify the name of a host computer.");
                return;
            }
            // Start the asynchronous request for DNS information.
            // This example does not use a delegate or user-supplied object
            // so the last two arguments are null.
            IAsyncResult result = Dns.BeginGetHostEntry(args[0], null, null);
            Console.WriteLine("Processing your request for information...");
            // Do any additional work that can be done here.
            try
            {
                // EndGetHostEntry blocks until the process completes.
                IPHostEntry host = Dns.EndGetHostEntry(result);
                string[] aliases = host.Aliases;
                IPAddress[] addresses = host.AddressList;
                if (aliases.Length > 0)
                {
                    Console.WriteLine("Aliases");
                    for (int i = 0; i < aliases.Length; i++)
                    {
                        Console.WriteLine("{0}", aliases[i]);
                    }
                }
                if (addresses.Length > 0)
                {
                    Console.WriteLine("Addresses");
                    for (int i = 0; i < addresses.Length; i++)
                    {
                        Console.WriteLine("{0}",addresses[i].ToString());
                    }
                }
            }
            catch (SocketException e)
            {
                Console.WriteLine("An exception occurred while processing the request: {0}", e.Message);
            }
        }
    }
}
```



### 使用 AsyncWaitHandle 阻止应用程序的执行

如果应用无法在等待异步操作结果期间继续执行其他工作，必须阻止应用一直到操作完成。 请使用下列方法之一，在应用等待异步操作完成期间阻止应用的主线程：

- 使用异步操作的 BeginOperationName 方法返回的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 的 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 属性。 本主题介绍的就是这种方法。
- 调用异步操作的 EndOperationName 方法。 有关展示这种方法的示例，请参阅[通过结束异步操作阻止应用执行](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/blocking-application-execution-by-ending-an-async-operation)。

在异步操作完成前使用一个或多个 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 对象阻止的应用，通常会调用 BeginOperationName 方法，执行任何不需要等待操作结果也可以执行的工作，并在一个或多个异步操作完成前一直处于阻止状态。 可以使用 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 调用 [WaitOne](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitone) 方法之一，对单个操作阻止应用。 若要在等待一组异步操作完成期间阻止应用，请将关联的 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 对象存储到数组中，并调用 [WaitAll](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitall) 方法之一。 若要在等待一组异步操作中任一操作完成期间阻止应用，请将关联的 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 对象存储到数组中，并调用 [WaitAny](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitany) 方法之一。

#### 示例

下面的代码示例展示了如何使用 DNS 类中的异步方法，检索用户指定计算机的域名系统信息。 此示例展示了如何使用与异步操作关联的 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 阻止应用。 请注意，对 [BeginGetHostByName](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns.begingethostbyname)`requestCallback` 和 `stateObject` 参数传递的是 `null`（Visual Basic 中的 `Nothing`），因为使用这种方法时这些是可选参数。

```C#
/*
The following example demonstrates using asynchronous methods to
get Domain Name System information for the specified host computer.

*/

using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class WaitUntilOperationCompletes
    {
        public static void Main(string[] args)
        {
            // Make sure the caller supplied a host name.
            if (args.Length == 0 || args[0].Length == 0)
            {
                // Print a message and exit.
                Console.WriteLine("You must specify the name of a host computer.");
                return;
            }
            // Start the asynchronous request for DNS information.
            IAsyncResult result = Dns.BeginGetHostEntry(args[0], null, null);
            Console.WriteLine("Processing request for information...");
            // Wait until the operation completes.
            result.AsyncWaitHandle.WaitOne();
            // The operation completed. Process the results.
            try
            {
                // Get the results.
                IPHostEntry host = Dns.EndGetHostEntry(result);
                string[] aliases = host.Aliases;
                IPAddress[] addresses = host.AddressList;
                if (aliases.Length > 0)
                {
                    Console.WriteLine("Aliases");
                    for (int i = 0; i < aliases.Length; i++)
                    {
                        Console.WriteLine("{0}", aliases[i]);
                    }
                }
                if (addresses.Length > 0)
                {
                    Console.WriteLine("Addresses");
                    for (int i = 0; i < addresses.Length; i++)
                    {
                        Console.WriteLine("{0}",addresses[i].ToString());
                    }
                }
            }
            catch (SocketException e)
            {
                Console.WriteLine("Exception occurred while processing the request: {0}",
                    e.Message);
            }
        }
    }
}
```



### 轮询异步操作的状态

如果应用可以在等待异步操作结果期间继续执行其他工作，不得阻止应用一直到操作完成。 请使用下列方法之一，在应用等待异步操作完成期间继续执行指令：

- 使用异步操作的 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted)[IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 方法返回的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 的 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted) 属性，确定操作是否已完成。 这种方法称为“轮询”，本主题介绍的就是它。
- 使用 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托，在单独的线程中处理异步操作结果。 有关展示这种方法的示例，请参阅[使用 AsyncCallback 委托结束异步操作](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/using-an-asynccallback-delegate-to-end-an-asynchronous-operation)。

#### 示例

下面的代码示例展示了如何使用 [Dns](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns) 类中的异步方法，检索用户指定计算机的域名系统信息。 此示例启动异步操作，然后在控制台打印句点 (".")，直到操作完成。 请注意，对 [BeginGetHostByName](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns.begingethostbyname)[AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 和 [Object](https://learn.microsoft.com/zh-cn/dotnet/api/system.object) 参数传递的是 null（Visual Basic 中的 Nothing），因为使用这种方法时这些是可选参数。

```C#
/*
The following example demonstrates using asynchronous methods to
get Domain Name System information for the specified host computer.
This example polls to detect the end of the asynchronous operation.
*/

using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class PollUntilOperationCompletes
    {
        static void UpdateUserInterface()
        {
            // Print a period to indicate that the application
            // is still working on the request.
            Console.Write(".");
        }
        public static void Main(string[] args)
        {
            // Make sure the caller supplied a host name.
            if (args.Length == 0 || args[0].Length == 0)
            {
                // Print a message and exit.
                Console.WriteLine("You must specify the name of a host computer.");
                return;
            }
            // Start the asynchronous request for DNS information.
            IAsyncResult result = Dns.BeginGetHostEntry(args[0], null, null);
            Console.WriteLine("Processing request for information...");

            // Poll for completion information.
            // Print periods (".") until the operation completes.
            while (result.IsCompleted != true)
            {
                UpdateUserInterface();
            }
            // The operation is complete. Process the results.
            // Print a new line.
            Console.WriteLine();
            try
            {
                IPHostEntry host = Dns.EndGetHostEntry(result);
                string[] aliases = host.Aliases;
                IPAddress[] addresses = host.AddressList;
                if (aliases.Length > 0)
                {
                    Console.WriteLine("Aliases");
                    for (int i = 0; i < aliases.Length; i++)
                    {
                        Console.WriteLine("{0}", aliases[i]);
                    }
                }
                if (addresses.Length > 0)
                {
                    Console.WriteLine("Addresses");
                    for (int i = 0; i < addresses.Length; i++)
                    {
                        Console.WriteLine("{0}",addresses[i].ToString());
                    }
                }
            }
            catch (SocketException e)
            {
                Console.WriteLine("An exception occurred while processing the request: {0}", e.Message);
            }
        }
    }
}
```



### 使用 AsyncCallback 委托结束异步操作

如果应用可以在等待异步操作结果期间继续执行其他工作，不得阻止应用一直到操作完成。 请使用下列方法之一，在应用等待异步操作完成期间继续执行指令：

- 使用 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托，在单独的线程中处理异步操作结果。 本主题介绍的就是这种方法。
- 使用异步操作的 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted)[IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 方法返回的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 的 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted) 属性，确定操作是否已完成。 有关展示这种方法的示例，请参阅[轮询异步操作状态](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/polling-for-the-status-of-an-asynchronous-operation)。

#### 示例

下面的代码示例展示了如何使用 [Dns](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns) 类中的异步方法，检索用户指定计算机的域名系统 (DNS) 信息。 此示例创建引用 `ProcessDnsInformation` 方法的 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托。 每次异步请求获取 DNS 信息，都会调用一次此方法。

请注意，将用户指定主机传递给 [BeginGetHostByName](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns.begingethostbyname)[Object](https://learn.microsoft.com/zh-cn/dotnet/api/system.object) 参数。 有关展示了如何定义和使用更复杂状态对象的示例，请参阅[使用 AsyncCallback 委托和状态对象](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/using-an-asynccallback-delegate-and-state-object)。

```C#
/*
The following example demonstrates using asynchronous methods to
get Domain Name System information for the specified host computers.
This example uses a delegate to obtain the results of each asynchronous
operation.
*/

using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Collections.Specialized;
using System.Collections;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class UseDelegateForAsyncCallback
    {
        static int requestCounter;
        static ArrayList hostData = new ArrayList();
        static StringCollection hostNames = new StringCollection();
        static void UpdateUserInterface()
        {
            // Print a message to indicate that the application
            // is still working on the remaining requests.
            Console.WriteLine("{0} requests remaining.", requestCounter);
        }
        public static void Main()
        {
            // Create the delegate that will process the results of the
            // asynchronous request.
            AsyncCallback callBack = new AsyncCallback(ProcessDnsInformation);
            string host;
            do
            {
                Console.Write(" Enter the name of a host computer or <enter> to finish: ");
                host = Console.ReadLine();
                if (host.Length > 0)
                {
                    // Increment the request counter in a thread safe manner.
                    Interlocked.Increment(ref requestCounter);
                    // Start the asynchronous request for DNS information.
                    Dns.BeginGetHostEntry(host, callBack, host);
                 }
            } while (host.Length > 0);
            // The user has entered all of the host names for lookup.
            // Now wait until the threads complete.
            while (requestCounter > 0)
            {
                UpdateUserInterface();
            }
            // Display the results.
            for (int i = 0; i< hostNames.Count; i++)
            {
                object data = hostData [i];
                string message = data as string;
                // A SocketException was thrown.
                if (message != null)
                {
                    Console.WriteLine("Request for {0} returned message: {1}",
                        hostNames[i], message);
                    continue;
                }
                // Get the results.
                IPHostEntry h = (IPHostEntry) data;
                string[] aliases = h.Aliases;
                IPAddress[] addresses = h.AddressList;
                if (aliases.Length > 0)
                {
                    Console.WriteLine("Aliases for {0}", hostNames[i]);
                    for (int j = 0; j < aliases.Length; j++)
                    {
                        Console.WriteLine("{0}", aliases[j]);
                    }
                }
                if (addresses.Length > 0)
                {
                    Console.WriteLine("Addresses for {0}", hostNames[i]);
                    for (int k = 0; k < addresses.Length; k++)
                    {
                        Console.WriteLine("{0}",addresses[k].ToString());
                    }
                }
            }
       }

        // The following method is called when each asynchronous operation completes.
        static void ProcessDnsInformation(IAsyncResult result)
        {
            string hostName = (string) result.AsyncState;
            hostNames.Add(hostName);
            try
            {
                // Get the results.
                IPHostEntry host = Dns.EndGetHostEntry(result);
                hostData.Add(host);
            }
            // Store the exception message.
            catch (SocketException e)
            {
                hostData.Add(e.Message);
            }
            finally
            {
                // Decrement the request counter in a thread-safe manner.
                Interlocked.Decrement(ref requestCounter);
            }
        }
    }
}
```



### 使用 AsyncCallback 委托和状态对象

使用 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托处理单独线程中的异步操作结果时，可以使用状态对象，在两个回调之间传递信息，并检索最终结果。 本主题通过扩展[使用 AsyncCallback 委托结束异步操作](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/using-an-asynccallback-delegate-to-end-an-asynchronous-operation)中的示例，展示了此做法。

#### 示例

下面的代码示例展示了如何使用 [Dns](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns) 类中的异步方法，检索用户指定计算机的域名系统 (DNS) 信息。 此示例定义并使用 `HostRequest` 类存储状态信息。 `HostRequest` 对象是针对用户输入的每个计算机名进行创建。 此对象传递给 [BeginGetHostByName](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns.begingethostbyname) 方法。 每当请求完成时，都会调用 `ProcessDnsInformation` 方法。 `HostRequest` 对象是使用 [AsyncState](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncstate) 属性进行检索。 `ProcessDnsInformation` 方法使用 `HostRequest` 对象，存储请求返回的 [IPHostEntry](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.iphostentry) 或请求抛出的 [SocketException](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socketexception)。 所有请求完成后，应用会循环访问 `HostRequest`对象，并显示 DNS 信息或 [SocketException](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socketexception) 错误消息。

```C#
/*
The following example demonstrates using asynchronous methods to
get Domain Name System information for the specified host computer.
*/

using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Collections;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
// Create a state object that holds each requested host name,
// an associated IPHostEntry object or a SocketException.
    public class HostRequest
    {
        // Stores the requested host name.
        private string hostName;
        // Stores any SocketException returned by the Dns EndGetHostByName method.
        private SocketException e;
        // Stores an IPHostEntry returned by the Dns EndGetHostByName method.
        private IPHostEntry entry;

        public HostRequest(string name)
        {
            hostName = name;
        }

        public string HostName
        {
            get
            {
                return hostName;
            }
        }

        public SocketException ExceptionObject
        {
            get
            {
                return e;
            }
            set
            {
                 e = value;
            }
        }

        public IPHostEntry HostEntry
        {
            get
            {
                return entry;
            }
            set
            {
                entry = value;
            }
        }
    }

    public class UseDelegateAndStateForAsyncCallback
    {
        // The number of pending requests.
        static int requestCounter;
        static ArrayList hostData = new ArrayList();
        static void UpdateUserInterface()
        {
            // Print a message to indicate that the application
            // is still working on the remaining requests.
            Console.WriteLine("{0} requests remaining.", requestCounter);
        }
        public static void Main()
        {
            // Create the delegate that will process the results of the
            // asynchronous request.
            AsyncCallback callBack = new AsyncCallback(ProcessDnsInformation);
            string host;
            do
            {
                Console.Write(" Enter the name of a host computer or <enter> to finish: ");
                host = Console.ReadLine();
                if (host.Length > 0)
                {
                    // Increment the request counter in a thread safe manner.
                    Interlocked.Increment(ref requestCounter);
                    // Create and store the state object for this request.
                    HostRequest request = new HostRequest(host);
                    hostData.Add(request);
                    // Start the asynchronous request for DNS information.
                    Dns.BeginGetHostEntry(host, callBack, request);
                 }
            } while (host.Length > 0);
            // The user has entered all of the host names for lookup.
            // Now wait until the threads complete.
            while (requestCounter > 0)
            {
                UpdateUserInterface();
            }
            // Display the results.
            foreach(HostRequest r in hostData)
            {
                    if (r.ExceptionObject != null)
                    {
                        Console.WriteLine("Request for host {0} returned the following error: {1}.",
                            r.HostName, r.ExceptionObject.Message);
                    }
                    else
                    {
                        // Get the results.
                        IPHostEntry h = r.HostEntry;
                        string[] aliases = h.Aliases;
                        IPAddress[] addresses = h.AddressList;
                        if (aliases.Length > 0)
                        {
                            Console.WriteLine("Aliases for {0}", r.HostName);
                            for (int j = 0; j < aliases.Length; j++)
                            {
                                Console.WriteLine("{0}", aliases[j]);
                            }
                        }
                        if (addresses.Length > 0)
                        {
                            Console.WriteLine("Addresses for {0}", r.HostName);
                            for (int k = 0; k < addresses.Length; k++)
                            {
                                Console.WriteLine("{0}",addresses[k].ToString());
                            }
                        }
                    }
            }
       }

        // The following method is invoked when each asynchronous operation completes.
        static void ProcessDnsInformation(IAsyncResult result)
        {
           // Get the state object associated with this request.
           HostRequest request = (HostRequest) result.AsyncState;
            try
            {
                // Get the results and store them in the state object.
                IPHostEntry host = Dns.EndGetHostEntry(result);
                request.HostEntry = host;
            }
            catch (SocketException e)
            {
                // Store any SocketExceptions.
                request.ExceptionObject = e;
            }
            finally
            {
                // Decrement the request counter in a thread-safe manner.
                Interlocked.Decrement(ref requestCounter);
            }
        }
    }
}
```



## 使用委托进行异步编程

使用委托可通过异步方式调用同步方法。 如果同步调用委托，`Invoke` 方法将在当前线程上直接调用目标方法。 如果调用 `BeginInvoke` 方法，公共语言运行时 (CLR) 将对请求进行排队并立即返回给调用方。 目标方法将在线程池中的某个线程上异步调用。 提交请求的原始线程可以不受限制地继续与目标方法并行执行。 如果已在对 `BeginInvoke` 方法的调用中指定回叫方法，则目标方法结束时，将调用回叫方法。 在回叫方法中，`EndInvoke` 方法将获取返回值和所有输入/输出或仅输出参数。 如果调用 `BeginInvoke` 时未指定回叫方法，则可能从调用 `BeginInvoke` 的线程上调用 `EndInvoke`。

> [!IMPORTANT]
> 编译器应使用由用户指定的委托签名，发出具有 `Invoke`、`BeginInvoke` 和 `EndInvoke` 方法的委托类。 `BeginInvoke` 和 `EndInvoke` 方法应标记为本机方法。 由于这些方法被标记为本机方法，CLR 将在类加载时自动提供实现。 加载程序可确保其不会被替代。

### 使用异步方式调用同步方法

使用 .NET 可以以异步方式调用任何方法。 为此，请定义一个委托，该委托具有与你要调用的方法相同的签名。 公共语言运行时将自动用适当的签名为此委托定义 `BeginInvoke` 和 `EndInvoke` 方法。

> [!NOTE]
> .NET Compact Framework 不支持异步委托调用，也就是 `BeginInvoke` 和 `EndInvoke` 方法。

`BeginInvoke` 方法启动异步调用。 该方法具有与你要异步执行的方法相同的参数，另加两个可选参数。 第一个参数是一个 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托，此委托引用在异步调用完成时要调用的方法。 第二个参数是一个用户定义的对象，该对象将信息传递到回调方法。 `BeginInvoke` 将立即返回，而不会等待异步调用完成。 `BeginInvoke` 返回可用于监视异步调用的进度的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult)。

`EndInvoke` 方法用于检索异步调用的结果。 它可以在调用 `BeginInvoke`之后的任意时间调用。 如果异步调用尚未完成，那么 `EndInvoke` 将阻止调用线程，直到完成异步调用。 `EndInvoke` 的参数包括要异步执行的方法的 `out` 和 `ref` 参数（Visual Basic 中的 `<Out>` `ByRef` 和 `ByRef`）以及 `BeginInvoke` 返回的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult)。

> [!NOTE]
> Visual Studio 中的 IntelliSense 功能可显示 `BeginInvoke` 和 `EndInvoke` 的参数。 如果未使用 Visual Studio 或类似工具，或者如果使用的是包含 Visual Studio 的 C#，请参阅[异步编程模型 (APM)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm)，获取关于为这些方法定义的参数的说明。

本主题的代码示例演示了使用 `BeginInvoke` 和 `EndInvoke` 进行异步调用的四种常用方法。 调用 `BeginInvoke` 之后可以执行以下操作：

- 执行一些操作，然后调用 `EndInvoke` 进行阻止，直到调用完成。
- 使用 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 属性获取 [IAsyncResult.AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) ，使用它的 [WaitOne](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitone) 方法阻止执行，直到 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 收到信号，然后调用 `EndInvoke`。
- 对由 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 返回的 `BeginInvoke` 进行轮询，以确定异步调用完成的时间，然后调用 `EndInvoke`。
- 将回调方法的委托传递到 `BeginInvoke`。 异步调用完成后在 [ThreadPool](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 线程上执行此方法。 回调方法将调用 `EndInvoke`。

> [!IMPORTANT]
> 无论使用何种方法，都要调用 `EndInvoke` 来完成异步调用。

#### 定义测试方法和异步委托

下面的代码示例演示了异步调用同一个长时间运行的方法 `TestMethod`的各种方式。 `TestMethod` 方法会显示一条控制台消息，说明该方法已开始处理，休眠了几秒钟，然后结束。 `TestMethod` 有一个 `out` 参数，该参数用于演示将此类参数添加到 `BeginInvoke` 和 `EndInvoke`的签名中的方式。 您可以按同样的方式处理 `ref` 参数。

下面的代码示例显示了 `TestMethod` 的定义和可用于异步调用 `AsyncMethodCaller` 的名称为 `TestMethod` 的委托。 要编译此代码示例，必须包括 `TestMethod` 和 `AsyncMethodCaller` 委托的定义。

```C#
using System;
using System.Threading;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class AsyncDemo
    {
        // The method to be executed asynchronously.
        public string TestMethod(int callDuration, out int threadId)
        {
            Console.WriteLine("Test method begins.");
            Thread.Sleep(callDuration);
            threadId = Thread.CurrentThread.ManagedThreadId;
            return String.Format("My call time was {0}.", callDuration.ToString());
        }
    }
    // The delegate must have the same signature as the method
    // it will call asynchronously.
    public delegate string AsyncMethodCaller(int callDuration, out int threadId);
}
```

#### 使用 EndInvoke 等待异步调用

异步执行方法的最简单方式是通过调用委托的 `BeginInvoke` 方法开始执行此方法，在主线程上执行一些操作，然后调用委托的 `EndInvoke` 方法。 `EndInvoke` 可能会阻止调用线程，因为该方法直到异步调用完成后才返回。 这种方式非常适合执行文件或网络操作。

> [!IMPORTANT]
> 因为 `EndInvoke` 可能会阻塞，所以不应从服务于用户界面的线程调用该方法。

```C#
using System;
using System.Threading;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class AsyncMain
    {
        public static void Main()
        {
            // The asynchronous method puts the thread id here.
            int threadId;

            // Create an instance of the test class.
            AsyncDemo ad = new AsyncDemo();

            // Create the delegate.
            AsyncMethodCaller caller = new AsyncMethodCaller(ad.TestMethod);

            // Initiate the asynchronous call.
            IAsyncResult result = caller.BeginInvoke(3000,
                out threadId, null, null);

            Thread.Sleep(0);
            Console.WriteLine("Main thread {0} does some work.",
                Thread.CurrentThread.ManagedThreadId);

            // Call EndInvoke to wait for the asynchronous call to complete,
            // and to retrieve the results.
            string returnValue = caller.EndInvoke(out threadId, result);

            Console.WriteLine("The call executed on thread {0}, with return value \"{1}\".",
                threadId, returnValue);
        }
    }
}

/* This example produces output similar to the following:

Main thread 1 does some work.
Test method begins.
The call executed on thread 3, with return value "My call time was 3000.".
 */
```

#### 使用 WaitHandle 等待异步调用

可以使用由 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 返回的 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 属性来获取 `BeginInvoke`。 当异步调用完成时 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 会收到信号，而你可以通过调用 [WaitOne](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitone) 方法来等待它。

如果你使用 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle)，则在异步调用完成前后你可以执行其他处理，但必须在调用 `EndInvoke` 检索结果之前。

> [!NOTE]
> 调用 `EndInvoke`时不会自动关闭等待句柄。 如果释放对等待句柄的所有引用，则当垃圾回收功能回收此等待句柄时将释放系统资源。 要在使用完等待句柄后立即释放系统资源，请通过调用 [WaitHandle.Close](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.close) 方法来释放等待句柄。 显式释放可释放对象时，垃圾回收的工作效率更高。

```C#
using System;
using System.Threading;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class AsyncMain
    {
        static void Main()
        {
            // The asynchronous method puts the thread id here.
            int threadId;

            // Create an instance of the test class.
            AsyncDemo ad = new AsyncDemo();

            // Create the delegate.
            AsyncMethodCaller caller = new AsyncMethodCaller(ad.TestMethod);

            // Initiate the asynchronous call.
            IAsyncResult result = caller.BeginInvoke(3000,
                out threadId, null, null);

            Thread.Sleep(0);
            Console.WriteLine("Main thread {0} does some work.",
                Thread.CurrentThread.ManagedThreadId);

            // Wait for the WaitHandle to become signaled.
            result.AsyncWaitHandle.WaitOne();

            // Perform additional processing here.
            // Call EndInvoke to retrieve the results.
            string returnValue = caller.EndInvoke(out threadId, result);

            // Close the wait handle.
            result.AsyncWaitHandle.Close();

            Console.WriteLine("The call executed on thread {0}, with return value \"{1}\".",
                threadId, returnValue);
        }
    }
}

/* This example produces output similar to the following:

Main thread 1 does some work.
Test method begins.
The call executed on thread 3, with return value "My call time was 3000.".
 */
```

#### 对异步调用的完成情况进行轮询

可以使用由 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted) 返回的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 的 `BeginInvoke` 属性来发现异步调用何时完成。 从服务于用户界面的线程执行异步调用时需要执行此操作。 对完成情况进行轮询允许在 [ThreadPool](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 线程中执行异步调用时继续执行调用线程。

```C#
using System;
using System.Threading;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class AsyncMain
    {
        static void Main() {
            // The asynchronous method puts the thread id here.
            int threadId;

            // Create an instance of the test class.
            AsyncDemo ad = new AsyncDemo();

            // Create the delegate.
            AsyncMethodCaller caller = new AsyncMethodCaller(ad.TestMethod);

            // Initiate the asynchronous call.
            IAsyncResult result = caller.BeginInvoke(3000,
                out threadId, null, null);

            // Poll while simulating work.
            while(result.IsCompleted == false) {
                Thread.Sleep(250);
                Console.Write(".");
            }

            // Call EndInvoke to retrieve the results.
            string returnValue = caller.EndInvoke(out threadId, result);

            Console.WriteLine("\nThe call executed on thread {0}, with return value \"{1}\".",
                threadId, returnValue);
        }
    }
}

/* This example produces output similar to the following:

Test method begins.
.............
The call executed on thread 3, with return value "My call time was 3000.".
 */
```

#### 异步调用完成时执行回调方法

如果启动异步调用的线程可以不是处理结果的线程，那么在调用完成时可以执行回调方法。 将在 [ThreadPool](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 线程上执行回调方法。

要使用回调方法，必须向 `BeginInvoke` 传递代表此回调方法的 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托。 你还可以传递包含此回调方法要使用的信息的对象。 在回调方法中，可以将此回调方法的唯一参数 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult)转换为 [AsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.remoting.messaging.asyncresult) 对象。 然后使用 [AsyncResult.AsyncDelegate](https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.remoting.messaging.asyncresult.asyncdelegate) 属性获取用于启动调用的委托，以便可以调用 `EndInvoke`。

有关示例的注释：

- `TestMethod` 的 `threadId` 参数为 `out` 参数（Visual Basic 中的 [`<Out>` `ByRef`），因此 `TestMethod` 从不使用它的输入值。 会将一个虚拟变量传递给 `BeginInvoke` 调用。 如果 `threadId` 参数是 `ref` 参数（Visual Basic 中的`ByRef` ），那么此变量应为一个类级字段，以便可以将它传递给 `BeginInvoke` 和 `EndInvoke`。
- 传递给 `BeginInvoke` 的状态信息是一个格式字符串，回调方法使用它来设置输出消息的格式。 因为该字符串是作为 [Object](https://learn.microsoft.com/zh-cn/dotnet/api/system.object)类型传递的，所以必须将此状态信息转换为适合的类型才可以使用。
- 回调是在 [ThreadPool](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 线程上进行的。 [ThreadPool](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 线程是后台线程，当主线程结束时该线程不会使应用程序继续运行，因此该示例的主线程必须休眠足够长的时间以等待回调完成。

```C#
using System;
using System.Threading;
using System.Runtime.Remoting.Messaging;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class AsyncMain
    {
        static void Main()
        {
            // Create an instance of the test class.
            AsyncDemo ad = new AsyncDemo();

            // Create the delegate.
            AsyncMethodCaller caller = new AsyncMethodCaller(ad.TestMethod);

            // The threadId parameter of TestMethod is an out parameter, so
            // its input value is never used by TestMethod. Therefore, a dummy
            // variable can be passed to the BeginInvoke call. If the threadId
            // parameter were a ref parameter, it would have to be a class-
            // level field so that it could be passed to both BeginInvoke and
            // EndInvoke.
            int dummy = 0;

            // Initiate the asynchronous call, passing three seconds (3000 ms)
            // for the callDuration parameter of TestMethod; a dummy variable
            // for the out parameter (threadId); the callback delegate; and
            // state information that can be retrieved by the callback method.
            // In this case, the state information is a string that can be used
            // to format a console message.
            IAsyncResult result = caller.BeginInvoke(3000,
                out dummy,
                new AsyncCallback(CallbackMethod),
                "The call executed on thread {0}, with return value \"{1}\".");

            Console.WriteLine("The main thread {0} continues to execute...",
                Thread.CurrentThread.ManagedThreadId);

            // The callback is made on a ThreadPool thread. ThreadPool threads
            // are background threads, which do not keep the application running
            // if the main thread ends. Comment out the next line to demonstrate
            // this.
            Thread.Sleep(4000);

            Console.WriteLine("The main thread ends.");
        }

        // The callback method must have the same signature as the
        // AsyncCallback delegate.
        static void CallbackMethod(IAsyncResult ar)
        {
            // Retrieve the delegate.
            AsyncResult result = (AsyncResult) ar;
            AsyncMethodCaller caller = (AsyncMethodCaller) result.AsyncDelegate;

            // Retrieve the format string that was passed as state
            // information.
            string formatString = (string) ar.AsyncState;

            // Define a variable to receive the value of the out parameter.
            // If the parameter were ref rather than out then it would have to
            // be a class-level field so it could also be passed to BeginInvoke.
            int threadId = 0;

            // Call EndInvoke to retrieve the results.
            string returnValue = caller.EndInvoke(out threadId, ar);

            // Use the format string to format the output message.
            Console.WriteLine(formatString, threadId, returnValue);
        }
    }
}

/* This example produces output similar to the following:

The main thread 1 continues to execute...
Test method begins.
The call executed on thread 3, with return value "My call time was 3000.".
The main thread ends.
 */
```





## 基于事件的异步模式 (EAP)

[Event-based Asynchronous Pattern (EAP) - .NET | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap)