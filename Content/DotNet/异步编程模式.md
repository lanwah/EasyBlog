# [异步编程模式(Asynchronous programming patterns)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/)

[TOC]

---

.NET 提供了执行异步操作的三种模式：

- **基于任务的异步模式 (TAP)** ，该模式使用单一方法表示异步操作的开始和完成。 TAP 是在 .NET Framework 4 中引入的。 **这是在 .NET 中进行异步编程的推荐方法。** C# 中的 [async](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/async) 和 [await](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/await) 关键词以及 Visual Basic 中的 [Async](https://learn.microsoft.com/zh-cn/dotnet/visual-basic/language-reference/modifiers/async) 和 [Await](https://learn.microsoft.com/zh-cn/dotnet/visual-basic/language-reference/operators/await-operator) 运算符为 TAP 添加了语言支持。 有关详细信息，请参阅[基于任务的异步模式 (TAP)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)。
- [**基于事件的异步模式 (EAP)**](#基于事件的异步模式 (EAP))，是提供异步行为的基于事件的旧模型。 这种模式需要后缀为 `Async` 的方法，以及一个或多个事件、事件处理程序委托类型和 `EventArg` 派生类型。 EAP 是在 .NET Framework 2.0 中引入的。 建议新开发中不再使用这种模式。 有关详细信息，请参阅[基于事件的异步模式 (EAP)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap)。
- [**异步编程模型 (APM) 模式**](#异步编程模型 (APM))（也称为 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式），这是使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 接口提供异步行为的旧模型。 在这种模式下，同步操作需要 `Begin` 和 `End` 方法（例如，`BeginWrite` 和 `EndWrite`以实现异步写入操作）。 不建议新的开发使用此模式。 有关详细信息，请参阅[异步编程模型 (APM)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm)。

## 模式的比较

为了快速比较这三种模式的异步操作方式，请考虑使用从指定偏移量处起将指定量数据读取到提供的缓冲区中的`Read`方法：

```C#
public class MyClass  
{  
    public int Read(byte [] buffer, int offset, int count);  
}
```

此方法对应的 TAP 将公开以下单个 `ReadAsync` 方法：

```C#
public class MyClass  
{  
    public Task<int> ReadAsync(byte [] buffer, int offset, int count);  
}
```

对应的 EAP 将公开以下类型和成员的集：

```C#
public class MyClass  
{  
    public void ReadAsync(byte [] buffer, int offset, int count);  
    public event ReadCompletedEventHandler ReadCompleted;  
}
```

对应的 APM 将公开 `BeginRead` 和 `EndRead` 方法：

```C#
public class MyClass  
{  
    public IAsyncResult BeginRead(  
        byte [] buffer, int offset, int count,
        AsyncCallback callback, object state);  
    public int EndRead(IAsyncResult asyncResult);  
}
```

## 请参阅

- [异步编程模式 | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/)



# 异步编程模型 (APM)

[Asynchronous Programming Model (APM)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm)

## 概述

使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 设计模式的异步操作是通过名为 `BeginOperationName` 和 `EndOperationName` 的两个方法来实现的，这两个方法分别开始和结束异步操作 OperationName。 例如， [FileStream](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.filestream) 类提供 [BeginRead](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.filestream.beginread) 和 [EndRead](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.filestream.endread) 方法来从文件异步读取字节。 这两个方法实现了 [Read](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.filestream.read) 方法的异步版本。

> [!NOTE]
> 从 .NET Framework 4 开始，任务并行库为异步和并行编程提供了一种新模型。 有关详细信息，请参阅 “[任务并行库 (TPL)](https://learn.microsoft.com/zh-cn/dotnet/standard/parallel-programming/task-parallel-library-tpl)” 和 “[基于任务的异步模式 (TAP)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)”。

在调用 `BeginOperationName` 后，应用程序可以继续在调用线程上执行指令，同时异步操作在另一个线程上执行。 每次调用 `BeginOperationName` 时，应用程序还应调用 `EndOperationName` 来获取操作的结果。

### 开始异步操作

`BeginOperationName` 方法开始异步操作 OperationName，并返回实现 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 接口的对象。 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 对象存储有关异步操作的信息。 下表显示有关异步操作的信息。

| 成员                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [AsyncState](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncstate) | 一个特定于应用程序的可选对象，其中包含有关异步操作的信息。   |
| [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) | 一个 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) ，可用来在异步操作完成之前阻止应用程序执行。 |
| [CompletedSynchronously](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.completedsynchronously) | 一个值，指示异步操作是否是在用于调用 `BeginOperationName` 的线程上完成，而不是在单独的 [ThreadPool](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 线程上完成。 |
| [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted) | 一个值，指示异步操作是否已完成。                             |

`BeginOperationName` 方法采用该方法的同步版本的签名中声明的任何参数（由值传递或由引用传递）。 `BeginOperationName` 方法签名中不包含任何输出参数。 `BeginOperationName` 方法签名另外还包括两个其他参数。 第一个参数定义一个 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托，此委托引用在异步操作完成时调用的方法。 如果调用方不希望在操作完成后调用方法，它可以指定 `null` （在 Visual Basic 中为`Nothing` ）。 第二个参数是一个用户定义的对象。 此对象可用来向异步操作完成时调用的方法传递应用程序特定的状态信息。 如果 `BeginOperationName` 方法还采用其他一些操作特定的参数（例如，一个用于存储从文件读取的字节的字节数组），则 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 和应用程序状态对象将是 `BeginOperationName` 方法签名中的最后两个参数。

`BeginOperationName` 立即返回对调用线程的控制。 如果 `BeginOperationName` 方法引发异常，则会在开始异步操作之前引发异常。 如果 `BeginOperationName` 方法引发异常，则意味着没有调用回调方法。

### 结束异步操作

`EndOperationName` 方法用于结束异步操作 OperationName。 `EndOperationName` 方法的返回值与其同步对应方法的返回值类型相同，并且是特定于异步操作的。 例如， [EndRead](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.filestream.endread) 方法返回从 [FileStream](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.filestream) 读取的字节数， [EndGetHostByName](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns.endgethostbyname) 方法返回包含有关主机的信息的 [IPHostEntry](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.iphostentry) 对象。 `EndOperationName` 方法采用该方法同步版本的签名中声明的所有输出参数或引用参数。 除了来自同步方法的参数外，`EndOperationName` 方法还包括 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 参数。 调用方必须将对应调用返回的实例传递给 `BeginOperationName`。

如果调用 `EndOperationName` 时 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 对象表示的异步操作尚未完成，则 `EndOperationName` 将在异步操作完成之前阻止调用线程。 异步操作引发的异常是从 `EndOperationName` 方法引发的。 未定义多次使用同一 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 调用 `EndOperationName` 方法的效果。 同样，也未定义使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult)（相关 Begin 方法未返回）调用 `EndOperationName` 方法的效果。

> [!NOTE]
> 对于这两种未定义的情况，实施者应考虑引发 [InvalidOperationException](https://learn.microsoft.com/zh-cn/dotnet/api/system.invalidoperationexception)。

> [!NOTE]
> 此设计模式的实施者应通知调用方异步操作已通过以下步骤完成：将 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted) 设置为 true，调用异步回调方法（如果已指定一个回调方法），然后发送 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle)信号。

对于访问异步操作的结果，应用程序开发人员有若干种设计选择。 正确的选择取决于应用程序是否有可以在操作完成时执行的指令。 如果应用程序在接收到异步操作结果之前不能进行任何其他工作，则必须在获得这些结果之前先阻止该应用程序进行其他工作。 若要在异步操作完成之前阻止应用程序，可以使用下列方法之一：

- 从应用程序的主线程调用 `EndOperationName`，阻止应用程序执行，直到操作完成之后再继续执行。 有关展示了此方法的示例，请参阅[通过结束异步操作阻止应用执行](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/blocking-application-execution-by-ending-an-async-operation)。
- 使用 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 来阻止应用程序执行，直到一个或多个操作完成。 有关演示此方法的示例，请参阅 “[使用 AsyncWaitHandle 阻止应用程序的执行](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/blocking-application-execution-using-an-asyncwaithandle)”。

在异步操作完成时不需要阻止的应用程序可使用下列方法之一：

- 按以下方式轮询操作完成状态：定期检查 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted) 属性，操作完成后调用 `EndOperationName`。 有关演示此方法的示例，请参阅 [轮询异步操作的状态](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/polling-for-the-status-of-an-asynchronous-operation)。
- 使用 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托来指定要在操作完成时调用的方法。 有关演示此方法的示例，请参阅 [使用 AsyncCallback 委托结束异步操作](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/using-an-asynccallback-delegate-to-end-an-asynchronous-operation)。

### 请参考

- [异步编程模型 (APM) - .NET | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm)



## 使用 IAsyncResult 调用异步方法

.NET 库和第三方类库中的类型可以提供方法，以便应用程序能够继续执行，同时在除主应用程序线程外的线程中执行异步操作。 下面各部分介绍并提供了代码示例，展示了可以调用使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 设计模式的异步方法的不同方式。

- [通过结束异步操作阻止应用执行](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/blocking-application-execution-by-ending-an-async-operation)。
- [使用 AsyncWaitHandle 阻止应用执行](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/blocking-application-execution-using-an-asyncwaithandle)。
- [轮询异步操作状态](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/polling-for-the-status-of-an-asynchronous-operation)。
- [使用 AsyncCallback 委托结束异步操作](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/using-an-asynccallback-delegate-to-end-an-asynchronous-operation)。

### 通过结束异步操作来阻止应用程序执行

如果应用无法在等待异步操作结果期间继续执行其他工作，必须阻止应用一直到操作完成。 请使用下列方法之一，在应用等待异步操作完成期间阻止应用的主线程：

- 调用异步操作的 EndOperationName 方法。 本主题介绍的就是这种方法。
- 使用异步操作的 BeginOperationName 方法返回的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 的 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 属性。 有关展示这种方法的示例，请参阅[使用 AsyncWaitHandle 阻止应用执行](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/blocking-application-execution-using-an-asyncwaithandle)。

在异步操作完成前使用 End*OperationName 方法阻止的应用程序，通常会调用 Begin\*OperationName 方法，执行任何不需要等待操作结果也可以执行的工作，然后调用 End\*OperationName***。

#### 示例

下面的代码示例展示了如何使用 [Dns](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns) 类中的异步方法，检索用户指定计算机的域名系统信息。 请注意，对 [BeginGetHostByName](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns.begingethostbyname)`requestCallback` 和 `stateObject` 参数传递的是 `null`（Visual Basic 中的 `Nothing`），因为使用这种方法时这些是可选参数。

```C#
/*
The following example demonstrates using asynchronous methods to
get Domain Name System information for the specified host computer.
*/

using System;
using System.Net;
using System.Net.Sockets;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class BlockUntilOperationCompletes
    {
        public static void Main(string[] args)
        {
            // Make sure the caller supplied a host name.
            if (args.Length == 0 || args[0].Length == 0)
            {
                // Print a message and exit.
                Console.WriteLine("You must specify the name of a host computer.");
                return;
            }
            // Start the asynchronous request for DNS information.
            // This example does not use a delegate or user-supplied object
            // so the last two arguments are null.
            IAsyncResult result = Dns.BeginGetHostEntry(args[0], null, null);
            Console.WriteLine("Processing your request for information...");
            // Do any additional work that can be done here.
            try
            {
                // EndGetHostEntry blocks until the process completes.
                IPHostEntry host = Dns.EndGetHostEntry(result);
                string[] aliases = host.Aliases;
                IPAddress[] addresses = host.AddressList;
                if (aliases.Length > 0)
                {
                    Console.WriteLine("Aliases");
                    for (int i = 0; i < aliases.Length; i++)
                    {
                        Console.WriteLine("{0}", aliases[i]);
                    }
                }
                if (addresses.Length > 0)
                {
                    Console.WriteLine("Addresses");
                    for (int i = 0; i < addresses.Length; i++)
                    {
                        Console.WriteLine("{0}",addresses[i].ToString());
                    }
                }
            }
            catch (SocketException e)
            {
                Console.WriteLine("An exception occurred while processing the request: {0}", e.Message);
            }
        }
    }
}
```



### 使用 AsyncWaitHandle 阻止应用程序的执行

如果应用无法在等待异步操作结果期间继续执行其他工作，必须阻止应用一直到操作完成。 请使用下列方法之一，在应用等待异步操作完成期间阻止应用的主线程：

- 使用异步操作的 BeginOperationName 方法返回的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 的 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 属性。 本主题介绍的就是这种方法。
- 调用异步操作的 EndOperationName 方法。 有关展示这种方法的示例，请参阅[通过结束异步操作阻止应用执行](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/blocking-application-execution-by-ending-an-async-operation)。

在异步操作完成前使用一个或多个 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 对象阻止的应用，通常会调用 BeginOperationName 方法，执行任何不需要等待操作结果也可以执行的工作，并在一个或多个异步操作完成前一直处于阻止状态。 可以使用 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 调用 [WaitOne](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitone) 方法之一，对单个操作阻止应用。 若要在等待一组异步操作完成期间阻止应用，请将关联的 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 对象存储到数组中，并调用 [WaitAll](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitall) 方法之一。 若要在等待一组异步操作中任一操作完成期间阻止应用，请将关联的 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 对象存储到数组中，并调用 [WaitAny](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitany) 方法之一。

#### 示例

下面的代码示例展示了如何使用 DNS 类中的异步方法，检索用户指定计算机的域名系统信息。 此示例展示了如何使用与异步操作关联的 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 阻止应用。 请注意，对 [BeginGetHostByName](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns.begingethostbyname)`requestCallback` 和 `stateObject` 参数传递的是 `null`（Visual Basic 中的 `Nothing`），因为使用这种方法时这些是可选参数。

```C#
/*
The following example demonstrates using asynchronous methods to
get Domain Name System information for the specified host computer.

*/

using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class WaitUntilOperationCompletes
    {
        public static void Main(string[] args)
        {
            // Make sure the caller supplied a host name.
            if (args.Length == 0 || args[0].Length == 0)
            {
                // Print a message and exit.
                Console.WriteLine("You must specify the name of a host computer.");
                return;
            }
            // Start the asynchronous request for DNS information.
            IAsyncResult result = Dns.BeginGetHostEntry(args[0], null, null);
            Console.WriteLine("Processing request for information...");
            // Wait until the operation completes.
            result.AsyncWaitHandle.WaitOne();
            // The operation completed. Process the results.
            try
            {
                // Get the results.
                IPHostEntry host = Dns.EndGetHostEntry(result);
                string[] aliases = host.Aliases;
                IPAddress[] addresses = host.AddressList;
                if (aliases.Length > 0)
                {
                    Console.WriteLine("Aliases");
                    for (int i = 0; i < aliases.Length; i++)
                    {
                        Console.WriteLine("{0}", aliases[i]);
                    }
                }
                if (addresses.Length > 0)
                {
                    Console.WriteLine("Addresses");
                    for (int i = 0; i < addresses.Length; i++)
                    {
                        Console.WriteLine("{0}",addresses[i].ToString());
                    }
                }
            }
            catch (SocketException e)
            {
                Console.WriteLine("Exception occurred while processing the request: {0}",
                    e.Message);
            }
        }
    }
}
```



### 轮询异步操作的状态

如果应用可以在等待异步操作结果期间继续执行其他工作，不得阻止应用一直到操作完成。 请使用下列方法之一，在应用等待异步操作完成期间继续执行指令：

- 使用异步操作的 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted)[IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 方法返回的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 的 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted) 属性，确定操作是否已完成。 这种方法称为“轮询”，本主题介绍的就是它。
- 使用 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托，在单独的线程中处理异步操作结果。 有关展示这种方法的示例，请参阅[使用 AsyncCallback 委托结束异步操作](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/using-an-asynccallback-delegate-to-end-an-asynchronous-operation)。

#### 示例

下面的代码示例展示了如何使用 [Dns](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns) 类中的异步方法，检索用户指定计算机的域名系统信息。 此示例启动异步操作，然后在控制台打印句点 (".")，直到操作完成。 请注意，对 [BeginGetHostByName](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns.begingethostbyname)[AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 和 [Object](https://learn.microsoft.com/zh-cn/dotnet/api/system.object) 参数传递的是 null（Visual Basic 中的 Nothing），因为使用这种方法时这些是可选参数。

```C#
/*
The following example demonstrates using asynchronous methods to
get Domain Name System information for the specified host computer.
This example polls to detect the end of the asynchronous operation.
*/

using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class PollUntilOperationCompletes
    {
        static void UpdateUserInterface()
        {
            // Print a period to indicate that the application
            // is still working on the request.
            Console.Write(".");
        }
        public static void Main(string[] args)
        {
            // Make sure the caller supplied a host name.
            if (args.Length == 0 || args[0].Length == 0)
            {
                // Print a message and exit.
                Console.WriteLine("You must specify the name of a host computer.");
                return;
            }
            // Start the asynchronous request for DNS information.
            IAsyncResult result = Dns.BeginGetHostEntry(args[0], null, null);
            Console.WriteLine("Processing request for information...");

            // Poll for completion information.
            // Print periods (".") until the operation completes.
            while (result.IsCompleted != true)
            {
                UpdateUserInterface();
            }
            // The operation is complete. Process the results.
            // Print a new line.
            Console.WriteLine();
            try
            {
                IPHostEntry host = Dns.EndGetHostEntry(result);
                string[] aliases = host.Aliases;
                IPAddress[] addresses = host.AddressList;
                if (aliases.Length > 0)
                {
                    Console.WriteLine("Aliases");
                    for (int i = 0; i < aliases.Length; i++)
                    {
                        Console.WriteLine("{0}", aliases[i]);
                    }
                }
                if (addresses.Length > 0)
                {
                    Console.WriteLine("Addresses");
                    for (int i = 0; i < addresses.Length; i++)
                    {
                        Console.WriteLine("{0}",addresses[i].ToString());
                    }
                }
            }
            catch (SocketException e)
            {
                Console.WriteLine("An exception occurred while processing the request: {0}", e.Message);
            }
        }
    }
}
```



### 使用 AsyncCallback 委托结束异步操作

如果应用可以在等待异步操作结果期间继续执行其他工作，不得阻止应用一直到操作完成。 请使用下列方法之一，在应用等待异步操作完成期间继续执行指令：

- 使用 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托，在单独的线程中处理异步操作结果。 本主题介绍的就是这种方法。
- 使用异步操作的 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted)[IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 方法返回的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 的 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted) 属性，确定操作是否已完成。 有关展示这种方法的示例，请参阅[轮询异步操作状态](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/polling-for-the-status-of-an-asynchronous-operation)。

#### 示例

下面的代码示例展示了如何使用 [Dns](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns) 类中的异步方法，检索用户指定计算机的域名系统 (DNS) 信息。 此示例创建引用 `ProcessDnsInformation` 方法的 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托。 每次异步请求获取 DNS 信息，都会调用一次此方法。

请注意，将用户指定主机传递给 [BeginGetHostByName](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns.begingethostbyname)[Object](https://learn.microsoft.com/zh-cn/dotnet/api/system.object) 参数。 有关展示了如何定义和使用更复杂状态对象的示例，请参阅[使用 AsyncCallback 委托和状态对象](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/using-an-asynccallback-delegate-and-state-object)。

```C#
/*
The following example demonstrates using asynchronous methods to
get Domain Name System information for the specified host computers.
This example uses a delegate to obtain the results of each asynchronous
operation.
*/

using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Collections.Specialized;
using System.Collections;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class UseDelegateForAsyncCallback
    {
        static int requestCounter;
        static ArrayList hostData = new ArrayList();
        static StringCollection hostNames = new StringCollection();
        static void UpdateUserInterface()
        {
            // Print a message to indicate that the application
            // is still working on the remaining requests.
            Console.WriteLine("{0} requests remaining.", requestCounter);
        }
        public static void Main()
        {
            // Create the delegate that will process the results of the
            // asynchronous request.
            AsyncCallback callBack = new AsyncCallback(ProcessDnsInformation);
            string host;
            do
            {
                Console.Write(" Enter the name of a host computer or <enter> to finish: ");
                host = Console.ReadLine();
                if (host.Length > 0)
                {
                    // Increment the request counter in a thread safe manner.
                    Interlocked.Increment(ref requestCounter);
                    // Start the asynchronous request for DNS information.
                    Dns.BeginGetHostEntry(host, callBack, host);
                 }
            } while (host.Length > 0);
            // The user has entered all of the host names for lookup.
            // Now wait until the threads complete.
            while (requestCounter > 0)
            {
                UpdateUserInterface();
            }
            // Display the results.
            for (int i = 0; i< hostNames.Count; i++)
            {
                object data = hostData [i];
                string message = data as string;
                // A SocketException was thrown.
                if (message != null)
                {
                    Console.WriteLine("Request for {0} returned message: {1}",
                        hostNames[i], message);
                    continue;
                }
                // Get the results.
                IPHostEntry h = (IPHostEntry) data;
                string[] aliases = h.Aliases;
                IPAddress[] addresses = h.AddressList;
                if (aliases.Length > 0)
                {
                    Console.WriteLine("Aliases for {0}", hostNames[i]);
                    for (int j = 0; j < aliases.Length; j++)
                    {
                        Console.WriteLine("{0}", aliases[j]);
                    }
                }
                if (addresses.Length > 0)
                {
                    Console.WriteLine("Addresses for {0}", hostNames[i]);
                    for (int k = 0; k < addresses.Length; k++)
                    {
                        Console.WriteLine("{0}",addresses[k].ToString());
                    }
                }
            }
       }

        // The following method is called when each asynchronous operation completes.
        static void ProcessDnsInformation(IAsyncResult result)
        {
            string hostName = (string) result.AsyncState;
            hostNames.Add(hostName);
            try
            {
                // Get the results.
                IPHostEntry host = Dns.EndGetHostEntry(result);
                hostData.Add(host);
            }
            // Store the exception message.
            catch (SocketException e)
            {
                hostData.Add(e.Message);
            }
            finally
            {
                // Decrement the request counter in a thread-safe manner.
                Interlocked.Decrement(ref requestCounter);
            }
        }
    }
}
```



### 使用 AsyncCallback 委托和状态对象

使用 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托处理单独线程中的异步操作结果时，可以使用状态对象，在两个回调之间传递信息，并检索最终结果。 本主题通过扩展[使用 AsyncCallback 委托结束异步操作](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/using-an-asynccallback-delegate-to-end-an-asynchronous-operation)中的示例，展示了此做法。

#### 示例

下面的代码示例展示了如何使用 [Dns](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns) 类中的异步方法，检索用户指定计算机的域名系统 (DNS) 信息。 此示例定义并使用 `HostRequest` 类存储状态信息。 `HostRequest` 对象是针对用户输入的每个计算机名进行创建。 此对象传递给 [BeginGetHostByName](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.dns.begingethostbyname) 方法。 每当请求完成时，都会调用 `ProcessDnsInformation` 方法。 `HostRequest` 对象是使用 [AsyncState](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncstate) 属性进行检索。 `ProcessDnsInformation` 方法使用 `HostRequest` 对象，存储请求返回的 [IPHostEntry](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.iphostentry) 或请求抛出的 [SocketException](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socketexception)。 所有请求完成后，应用会循环访问 `HostRequest`对象，并显示 DNS 信息或 [SocketException](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socketexception) 错误消息。

```C#
/*
The following example demonstrates using asynchronous methods to
get Domain Name System information for the specified host computer.
*/

using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Collections;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
// Create a state object that holds each requested host name,
// an associated IPHostEntry object or a SocketException.
    public class HostRequest
    {
        // Stores the requested host name.
        private string hostName;
        // Stores any SocketException returned by the Dns EndGetHostByName method.
        private SocketException e;
        // Stores an IPHostEntry returned by the Dns EndGetHostByName method.
        private IPHostEntry entry;

        public HostRequest(string name)
        {
            hostName = name;
        }

        public string HostName
        {
            get
            {
                return hostName;
            }
        }

        public SocketException ExceptionObject
        {
            get
            {
                return e;
            }
            set
            {
                 e = value;
            }
        }

        public IPHostEntry HostEntry
        {
            get
            {
                return entry;
            }
            set
            {
                entry = value;
            }
        }
    }

    public class UseDelegateAndStateForAsyncCallback
    {
        // The number of pending requests.
        static int requestCounter;
        static ArrayList hostData = new ArrayList();
        static void UpdateUserInterface()
        {
            // Print a message to indicate that the application
            // is still working on the remaining requests.
            Console.WriteLine("{0} requests remaining.", requestCounter);
        }
        public static void Main()
        {
            // Create the delegate that will process the results of the
            // asynchronous request.
            AsyncCallback callBack = new AsyncCallback(ProcessDnsInformation);
            string host;
            do
            {
                Console.Write(" Enter the name of a host computer or <enter> to finish: ");
                host = Console.ReadLine();
                if (host.Length > 0)
                {
                    // Increment the request counter in a thread safe manner.
                    Interlocked.Increment(ref requestCounter);
                    // Create and store the state object for this request.
                    HostRequest request = new HostRequest(host);
                    hostData.Add(request);
                    // Start the asynchronous request for DNS information.
                    Dns.BeginGetHostEntry(host, callBack, request);
                 }
            } while (host.Length > 0);
            // The user has entered all of the host names for lookup.
            // Now wait until the threads complete.
            while (requestCounter > 0)
            {
                UpdateUserInterface();
            }
            // Display the results.
            foreach(HostRequest r in hostData)
            {
                    if (r.ExceptionObject != null)
                    {
                        Console.WriteLine("Request for host {0} returned the following error: {1}.",
                            r.HostName, r.ExceptionObject.Message);
                    }
                    else
                    {
                        // Get the results.
                        IPHostEntry h = r.HostEntry;
                        string[] aliases = h.Aliases;
                        IPAddress[] addresses = h.AddressList;
                        if (aliases.Length > 0)
                        {
                            Console.WriteLine("Aliases for {0}", r.HostName);
                            for (int j = 0; j < aliases.Length; j++)
                            {
                                Console.WriteLine("{0}", aliases[j]);
                            }
                        }
                        if (addresses.Length > 0)
                        {
                            Console.WriteLine("Addresses for {0}", r.HostName);
                            for (int k = 0; k < addresses.Length; k++)
                            {
                                Console.WriteLine("{0}",addresses[k].ToString());
                            }
                        }
                    }
            }
       }

        // The following method is invoked when each asynchronous operation completes.
        static void ProcessDnsInformation(IAsyncResult result)
        {
           // Get the state object associated with this request.
           HostRequest request = (HostRequest) result.AsyncState;
            try
            {
                // Get the results and store them in the state object.
                IPHostEntry host = Dns.EndGetHostEntry(result);
                request.HostEntry = host;
            }
            catch (SocketException e)
            {
                // Store any SocketExceptions.
                request.ExceptionObject = e;
            }
            finally
            {
                // Decrement the request counter in a thread-safe manner.
                Interlocked.Decrement(ref requestCounter);
            }
        }
    }
}
```



## 使用委托进行异步编程

使用委托可通过异步方式调用同步方法。 如果同步调用委托，`Invoke` 方法将在当前线程上直接调用目标方法。 如果调用 `BeginInvoke` 方法，公共语言运行时 (CLR) 将对请求进行排队并立即返回给调用方。 目标方法将在线程池中的某个线程上异步调用。 提交请求的原始线程可以不受限制地继续与目标方法并行执行。 如果已在对 `BeginInvoke` 方法的调用中指定回叫方法，则目标方法结束时，将调用回叫方法。 在回叫方法中，`EndInvoke` 方法将获取返回值和所有输入/输出或仅输出参数。 如果调用 `BeginInvoke` 时未指定回叫方法，则可能从调用 `BeginInvoke` 的线程上调用 `EndInvoke`。

> [!IMPORTANT]
> 编译器应使用由用户指定的委托签名，发出具有 `Invoke`、`BeginInvoke` 和 `EndInvoke` 方法的委托类。 `BeginInvoke` 和 `EndInvoke` 方法应标记为本机方法。 由于这些方法被标记为本机方法，CLR 将在类加载时自动提供实现。 加载程序可确保其不会被替代。

### 使用异步方式调用同步方法

使用 .NET 可以以异步方式调用任何方法。 为此，请定义一个委托，该委托具有与你要调用的方法相同的签名。 公共语言运行时将自动用适当的签名为此委托定义 `BeginInvoke` 和 `EndInvoke` 方法。

> [!NOTE]
> .NET Compact Framework 不支持异步委托调用，也就是 `BeginInvoke` 和 `EndInvoke` 方法。

`BeginInvoke` 方法启动异步调用。 该方法具有与你要异步执行的方法相同的参数，另加两个可选参数。 第一个参数是一个 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托，此委托引用在异步调用完成时要调用的方法。 第二个参数是一个用户定义的对象，该对象将信息传递到回调方法。 `BeginInvoke` 将立即返回，而不会等待异步调用完成。 `BeginInvoke` 返回可用于监视异步调用的进度的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult)。

`EndInvoke` 方法用于检索异步调用的结果。 它可以在调用 `BeginInvoke`之后的任意时间调用。 如果异步调用尚未完成，那么 `EndInvoke` 将阻止调用线程，直到完成异步调用。 `EndInvoke` 的参数包括要异步执行的方法的 `out` 和 `ref` 参数（Visual Basic 中的 `<Out>` `ByRef` 和 `ByRef`）以及 `BeginInvoke` 返回的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult)。

> [!NOTE]
> Visual Studio 中的 IntelliSense 功能可显示 `BeginInvoke` 和 `EndInvoke` 的参数。 如果未使用 Visual Studio 或类似工具，或者如果使用的是包含 Visual Studio 的 C#，请参阅[异步编程模型 (APM)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm)，获取关于为这些方法定义的参数的说明。

本主题的代码示例演示了使用 `BeginInvoke` 和 `EndInvoke` 进行异步调用的四种常用方法。 调用 `BeginInvoke` 之后可以执行以下操作：

- 执行一些操作，然后调用 `EndInvoke` 进行阻止，直到调用完成。
- 使用 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 属性获取 [IAsyncResult.AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) ，使用它的 [WaitOne](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitone) 方法阻止执行，直到 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 收到信号，然后调用 `EndInvoke`。
- 对由 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 返回的 `BeginInvoke` 进行轮询，以确定异步调用完成的时间，然后调用 `EndInvoke`。
- 将回调方法的委托传递到 `BeginInvoke`。 异步调用完成后在 [ThreadPool](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 线程上执行此方法。 回调方法将调用 `EndInvoke`。

> [!IMPORTANT]
> 无论使用何种方法，都要调用 `EndInvoke` 来完成异步调用。

#### 定义测试方法和异步委托

下面的代码示例演示了异步调用同一个长时间运行的方法 `TestMethod`的各种方式。 `TestMethod` 方法会显示一条控制台消息，说明该方法已开始处理，休眠了几秒钟，然后结束。 `TestMethod` 有一个 `out` 参数，该参数用于演示将此类参数添加到 `BeginInvoke` 和 `EndInvoke`的签名中的方式。 您可以按同样的方式处理 `ref` 参数。

下面的代码示例显示了 `TestMethod` 的定义和可用于异步调用 `AsyncMethodCaller` 的名称为 `TestMethod` 的委托。 要编译此代码示例，必须包括 `TestMethod` 和 `AsyncMethodCaller` 委托的定义。

```C#
using System;
using System.Threading;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class AsyncDemo
    {
        // The method to be executed asynchronously.
        public string TestMethod(int callDuration, out int threadId)
        {
            Console.WriteLine("Test method begins.");
            Thread.Sleep(callDuration);
            threadId = Thread.CurrentThread.ManagedThreadId;
            return String.Format("My call time was {0}.", callDuration.ToString());
        }
    }
    // The delegate must have the same signature as the method
    // it will call asynchronously.
    public delegate string AsyncMethodCaller(int callDuration, out int threadId);
}
```

#### 使用 EndInvoke 等待异步调用

异步执行方法的最简单方式是通过调用委托的 `BeginInvoke` 方法开始执行此方法，在主线程上执行一些操作，然后调用委托的 `EndInvoke` 方法。 `EndInvoke` 可能会阻止调用线程，因为该方法直到异步调用完成后才返回。 这种方式非常适合执行文件或网络操作。

> [!IMPORTANT]
> 因为 `EndInvoke` 可能会阻塞，所以不应从服务于用户界面的线程调用该方法。

```C#
using System;
using System.Threading;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class AsyncMain
    {
        public static void Main()
        {
            // The asynchronous method puts the thread id here.
            int threadId;

            // Create an instance of the test class.
            AsyncDemo ad = new AsyncDemo();

            // Create the delegate.
            AsyncMethodCaller caller = new AsyncMethodCaller(ad.TestMethod);

            // Initiate the asynchronous call.
            IAsyncResult result = caller.BeginInvoke(3000,
                out threadId, null, null);

            Thread.Sleep(0);
            Console.WriteLine("Main thread {0} does some work.",
                Thread.CurrentThread.ManagedThreadId);

            // Call EndInvoke to wait for the asynchronous call to complete,
            // and to retrieve the results.
            string returnValue = caller.EndInvoke(out threadId, result);

            Console.WriteLine("The call executed on thread {0}, with return value \"{1}\".",
                threadId, returnValue);
        }
    }
}

/* This example produces output similar to the following:

Main thread 1 does some work.
Test method begins.
The call executed on thread 3, with return value "My call time was 3000.".
 */
```

#### 使用 WaitHandle 等待异步调用

可以使用由 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 返回的 [AsyncWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.asyncwaithandle) 的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 属性来获取 `BeginInvoke`。 当异步调用完成时 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 会收到信号，而你可以通过调用 [WaitOne](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitone) 方法来等待它。

如果你使用 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle)，则在异步调用完成前后你可以执行其他处理，但必须在调用 `EndInvoke` 检索结果之前。

> [!NOTE]
> 调用 `EndInvoke`时不会自动关闭等待句柄。 如果释放对等待句柄的所有引用，则当垃圾回收功能回收此等待句柄时将释放系统资源。 要在使用完等待句柄后立即释放系统资源，请通过调用 [WaitHandle.Close](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.close) 方法来释放等待句柄。 显式释放可释放对象时，垃圾回收的工作效率更高。

```C#
using System;
using System.Threading;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class AsyncMain
    {
        static void Main()
        {
            // The asynchronous method puts the thread id here.
            int threadId;

            // Create an instance of the test class.
            AsyncDemo ad = new AsyncDemo();

            // Create the delegate.
            AsyncMethodCaller caller = new AsyncMethodCaller(ad.TestMethod);

            // Initiate the asynchronous call.
            IAsyncResult result = caller.BeginInvoke(3000,
                out threadId, null, null);

            Thread.Sleep(0);
            Console.WriteLine("Main thread {0} does some work.",
                Thread.CurrentThread.ManagedThreadId);

            // Wait for the WaitHandle to become signaled.
            result.AsyncWaitHandle.WaitOne();

            // Perform additional processing here.
            // Call EndInvoke to retrieve the results.
            string returnValue = caller.EndInvoke(out threadId, result);

            // Close the wait handle.
            result.AsyncWaitHandle.Close();

            Console.WriteLine("The call executed on thread {0}, with return value \"{1}\".",
                threadId, returnValue);
        }
    }
}

/* This example produces output similar to the following:

Main thread 1 does some work.
Test method begins.
The call executed on thread 3, with return value "My call time was 3000.".
 */
```

#### 对异步调用的完成情况进行轮询

可以使用由 [IsCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult.iscompleted) 返回的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 的 `BeginInvoke` 属性来发现异步调用何时完成。 从服务于用户界面的线程执行异步调用时需要执行此操作。 对完成情况进行轮询允许在 [ThreadPool](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 线程中执行异步调用时继续执行调用线程。

```C#
using System;
using System.Threading;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class AsyncMain
    {
        static void Main() {
            // The asynchronous method puts the thread id here.
            int threadId;

            // Create an instance of the test class.
            AsyncDemo ad = new AsyncDemo();

            // Create the delegate.
            AsyncMethodCaller caller = new AsyncMethodCaller(ad.TestMethod);

            // Initiate the asynchronous call.
            IAsyncResult result = caller.BeginInvoke(3000,
                out threadId, null, null);

            // Poll while simulating work.
            while(result.IsCompleted == false) {
                Thread.Sleep(250);
                Console.Write(".");
            }

            // Call EndInvoke to retrieve the results.
            string returnValue = caller.EndInvoke(out threadId, result);

            Console.WriteLine("\nThe call executed on thread {0}, with return value \"{1}\".",
                threadId, returnValue);
        }
    }
}

/* This example produces output similar to the following:

Test method begins.
.............
The call executed on thread 3, with return value "My call time was 3000.".
 */
```

#### 异步调用完成时执行回调方法

如果启动异步调用的线程可以不是处理结果的线程，那么在调用完成时可以执行回调方法。 将在 [ThreadPool](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 线程上执行回调方法。

要使用回调方法，必须向 `BeginInvoke` 传递代表此回调方法的 [AsyncCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.asynccallback) 委托。 你还可以传递包含此回调方法要使用的信息的对象。 在回调方法中，可以将此回调方法的唯一参数 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult)转换为 [AsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.remoting.messaging.asyncresult) 对象。 然后使用 [AsyncResult.AsyncDelegate](https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.remoting.messaging.asyncresult.asyncdelegate) 属性获取用于启动调用的委托，以便可以调用 `EndInvoke`。

有关示例的注释：

- `TestMethod` 的 `threadId` 参数为 `out` 参数（Visual Basic 中的 [`<Out>` `ByRef`），因此 `TestMethod` 从不使用它的输入值。 会将一个虚拟变量传递给 `BeginInvoke` 调用。 如果 `threadId` 参数是 `ref` 参数（Visual Basic 中的`ByRef` ），那么此变量应为一个类级字段，以便可以将它传递给 `BeginInvoke` 和 `EndInvoke`。
- 传递给 `BeginInvoke` 的状态信息是一个格式字符串，回调方法使用它来设置输出消息的格式。 因为该字符串是作为 [Object](https://learn.microsoft.com/zh-cn/dotnet/api/system.object)类型传递的，所以必须将此状态信息转换为适合的类型才可以使用。
- 回调是在 [ThreadPool](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 线程上进行的。 [ThreadPool](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 线程是后台线程，当主线程结束时该线程不会使应用程序继续运行，因此该示例的主线程必须休眠足够长的时间以等待回调完成。

```C#
using System;
using System.Threading;
using System.Runtime.Remoting.Messaging;

namespace Examples.AdvancedProgramming.AsynchronousOperations
{
    public class AsyncMain
    {
        static void Main()
        {
            // Create an instance of the test class.
            AsyncDemo ad = new AsyncDemo();

            // Create the delegate.
            AsyncMethodCaller caller = new AsyncMethodCaller(ad.TestMethod);

            // The threadId parameter of TestMethod is an out parameter, so
            // its input value is never used by TestMethod. Therefore, a dummy
            // variable can be passed to the BeginInvoke call. If the threadId
            // parameter were a ref parameter, it would have to be a class-
            // level field so that it could be passed to both BeginInvoke and
            // EndInvoke.
            int dummy = 0;

            // Initiate the asynchronous call, passing three seconds (3000 ms)
            // for the callDuration parameter of TestMethod; a dummy variable
            // for the out parameter (threadId); the callback delegate; and
            // state information that can be retrieved by the callback method.
            // In this case, the state information is a string that can be used
            // to format a console message.
            IAsyncResult result = caller.BeginInvoke(3000,
                out dummy,
                new AsyncCallback(CallbackMethod),
                "The call executed on thread {0}, with return value \"{1}\".");

            Console.WriteLine("The main thread {0} continues to execute...",
                Thread.CurrentThread.ManagedThreadId);

            // The callback is made on a ThreadPool thread. ThreadPool threads
            // are background threads, which do not keep the application running
            // if the main thread ends. Comment out the next line to demonstrate
            // this.
            Thread.Sleep(4000);

            Console.WriteLine("The main thread ends.");
        }

        // The callback method must have the same signature as the
        // AsyncCallback delegate.
        static void CallbackMethod(IAsyncResult ar)
        {
            // Retrieve the delegate.
            AsyncResult result = (AsyncResult) ar;
            AsyncMethodCaller caller = (AsyncMethodCaller) result.AsyncDelegate;

            // Retrieve the format string that was passed as state
            // information.
            string formatString = (string) ar.AsyncState;

            // Define a variable to receive the value of the out parameter.
            // If the parameter were ref rather than out then it would have to
            // be a class-level field so it could also be passed to BeginInvoke.
            int threadId = 0;

            // Call EndInvoke to retrieve the results.
            string returnValue = caller.EndInvoke(out threadId, ar);

            // Use the format string to format the output message.
            Console.WriteLine(formatString, threadId, returnValue);
        }
    }
}

/* This example produces output similar to the following:

The main thread 1 continues to execute...
Test method begins.
The call executed on thread 3, with return value "My call time was 3000.".
The main thread ends.
 */
```



## 相关参考

- [异步编程模型 (APM) - .NET | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm)

- [委托 - C# 编程指南 | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/delegates/)
  - [Delegate 类 (System) | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/api/system.delegate?view=net-9.0)
  - [使用委托中的变体 - C# | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-delegates)
- [Thread 类 (System.Threading) | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.thread?view=net-9.0)



# 基于事件的异步模式 (EAP)

[Event-based Asynchronous Pattern (EAP) - .NET | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap)

## 基于事件的异步模式概述

那些同时执行多项任务、但仍能响应用户交互的应用程序通常需要实施一种使用多线程的设计方案。 [System.Threading](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading) 命名空间提供了创建高性能多线程应用程序所必需的所有工具，但要想有效地使用这些工具，需要有丰富的使用多线程软件工程的经验。 对于相对简单的多线程应用程序，[BackgroundWorker](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.backgroundworker) 组件提供了一个简单的解决方案。 对于更复杂的异步应用程序，请考虑实现一个符合基于事件的异步模式的类。

基于事件的异步模式具有多线程应用程序的优点，同时隐藏了多线程设计中固有的许多复杂问题。 使用支持此模式的类，你将能够：

- “在后台”执行耗时任务（例如下载和数据库操作），但不会中断你的应用程序。
- 同时执行多个操作，每个操作完成时都会接到通知。
- 等待资源变得可用，但不会停止（“阻止”）你的应用程序。
- 使用熟悉的事件和委托模型与挂起的异步操作通信。 若要详细了解如何使用事件处理程序和委托，请参阅[事件](https://learn.microsoft.com/zh-cn/dotnet/standard/events/)。

支持基于事件的异步模式的类将具有一个或多个命名为 *MethodName***Async** 的方法。 这些方法可能会创建同步版本的镜像，这些同步版本会在当前线程上执行相同的操作。 该类还可能具有 *MethodName***Completed** 事件，并且可能会具有 *MethodName***AsyncCancel**（或只是 **CancelAsync**）方法。

[PictureBox](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.picturebox) 是一个支持基于事件的异步模式的典型组件。 你可以通过调用其 [Load](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.picturebox.load) 方法来同步下载图像，但是如果图像很大，或者网络连接很慢，应用程序将停止响应，直到下载操作完成并且对 [Load](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.picturebox.load) 的调用返回后才会继续执行。

如果你想要应用程序在加载图像时保持运行，你可以调用 [LoadAsync](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.picturebox.loadasync) 方法，处理 [LoadCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.picturebox.loadcompleted#system-windows-forms-picturebox-loadcompleted) 事件，这与你处理任何其他事件一样。 调用 [LoadAsync](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.picturebox.loadasync) 方法时，你的应用程序将继续运行，而下载操作将在另一个线程上（“在后台”）继续。 图像加载操作完成时，将调用你的事件处理程序，并且你的事件处理程序可以检查 [AsyncCompletedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs) 参数以确定该下载是否已成功完成。

基于事件的异步模式要求异步操作可以取消，并且 [PictureBox](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.picturebox) 控件使用其 [CancelAsync](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.picturebox.cancelasync) 方法支持此要求。 调用 [CancelAsync](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.picturebox.cancelasync) 会提交一个停止挂起的下载的请求，任务取消时会引发 [LoadCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.picturebox.loadcompleted#system-windows-forms-picturebox-loadcompleted) 事件。

> [!CAUTION] 
> 下载有可能刚好在发出 [CancelAsync](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.picturebox.cancelasync) 请求时完成，因此 [Cancelled](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs.cancelled) 可能没有反映取消请求。 这称为“争用条件”，也是多线程编程中的常见问题。 若要详细了解多线程编程中的问题，请参阅[托管线程最佳做法](https://learn.microsoft.com/zh-cn/dotnet/standard/threading/managed-threading-best-practices)。

### 基于事件的异步模式的特征

基于事件的异步模式可以采用多种形式，具体取决于某个特定类支持的操作的复杂程度。 最简单的类可能包含一个 *MethodName***Async** 方法和对应的 M*MethodName***Completed** 事件。 更复杂的类可能包含多个 *MethodName***Async** 方法（每个方法具有一个对应的 *MethodName***Completed** 事件），以及这些方法的同步版本。 这些类有选择性地分别支持各种异步方法的取消、进度报告和增量结果。

异步方法可能还支持多个挂起的调用（多个并发调用），允许你的代码在此方法完成其他挂起的操作之前调用此方法任意多次。 若要正确处理此种情况，需要让你的应用程序能够跟踪各个操作的完成。

#### 基于事件的异步模式示例

[SoundPlayer](https://learn.microsoft.com/zh-cn/dotnet/api/system.media.soundplayer) 和 [PictureBox](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.picturebox) 组件表示基于事件的异步模式的简单实现。 [WebClient](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.webclient) 和 [BackgroundWorker](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.backgroundworker) 组件表示基于事件的异步模式的更复杂实现。

下面是一个符合此模式的类声明示例：

```C#
public class AsyncExample  
{  
    // Synchronous methods.  
    public int Method1(string param);  
    public void Method2(double param);  
  
    // Asynchronous methods.  
    public void Method1Async(string param);  
    public void Method1Async(string param, object userState);  
    public event Method1CompletedEventHandler Method1Completed;  
  
    public void Method2Async(double param);  
    public void Method2Async(double param, object userState);  
    public event Method2CompletedEventHandler Method2Completed;  
  
    public void CancelAsync(object userState);  
  
    public bool IsBusy { get; }  
  
    // Class implementation not shown.  
}
```

这里虚构的 `AsyncExample` 类有两个方法，都支持同步和异步调用。 同步重载的行为类似于方法调用，它们对调用线程执行操作；如果操作很耗时，则调用的返回可能会有明显的延迟。 异步重载将在另一个线程上启动操作，然后立即返回，允许在调用线程继续执行的同时让操作“在后台”执行。

#### 异步方法重载

异步操作可以有两个重载：单调用和多调用。 你可以通过方法签名来区分这两种形式：多调用形式有一个额外的参数，即 `userState`。 使用这种形式，你的代码可以多次调用 `Method1Async(string param, object userState)`，而不必等待任何挂起的异步操作的完成。 另一方面，如果你尝试在前一个调用尚未完成时调用 `Method1Async(string param)`，该方法将引发 [InvalidOperationException](https://learn.microsoft.com/zh-cn/dotnet/api/system.invalidoperationexception)。

多调用重载的 `userState` 参数可帮助你区分各个异步操作。 应分别为各个 `Method1Async(string param, object userState)` 调用提供唯一值（例如，GUID 或哈希代码）；这样，当各个操作完成时，事件处理程序便可以确定是哪个操作实例抛出了完成事件。

#### 跟踪挂起的操作

如果你使用多调用重载，你的代码将需要跟踪挂起任务的 `userState` 对象（任务 ID）。 对于各个 `Method1Async(string param, object userState)` 调用，通常会生成新的唯一 `userState` 对象，并将它添加到集合中。 当对应于此 `userState` 对象的任务引发完成事件时，你的完成方法实现将检查 [AsyncCompletedEventArgs.UserState](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs.userstate) 并将此对象从集合中删除。 在以这种方式使用时，`userState` 参数充当任务 ID 的角色。

> [!NOTE]
> 在为你对多调用重载的调用中的 `userState` 提供唯一值时，一定要小心。 如果任务 ID 不唯一，将导致异步类引发 [ArgumentException](https://learn.microsoft.com/zh-cn/dotnet/api/system.argumentexception)。

#### 取消挂起的操作

我们必须能够在异步操作完成之前随时取消它们，这一点很重要。 实现基于事件的异步模式的类包含 `CancelAsync` 方法（如果只有一个异步方法），或 *MethodName***AsyncCancel** 方法（如果有多个异步方法）。

允许多个调用采用 `userState` 参数的方法，此类方法可用于跟踪每个任务的生存期。 `CancelAsync` 采用 `userState` 参数，该参数可用于取消特定挂起任务。

一次只支持一个挂起操作的方法（如 `Method1Async(string param)`）是不可取消的。

#### 接收进度更新和增量结果

符合基于事件的异步模式的类可以为跟踪进度和增量结果提供事件。 此事件通常命名为 `ProgressChanged` 或 *MethodName***ProgressChanged**，其对应的事件处理程序将使用 [ProgressChangedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs) 参数。

`ProgressChanged` 事件的事件处理程序可以检查 [ProgressChangedEventArgs.ProgressPercentage](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs.progresspercentage) 属性，以确定异步任务完成百分比。 此属性的范围是 0 到 100，可用来更新 [Value](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.progressbar.value) 的 [ProgressBar](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.progressbar) 属性。 如果有多个异步操作挂起，你可以使用 [ProgressChangedEventArgs.UserState](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs.userstate) 属性来分辨出哪个操作在报告进度。

一些类可能会在异步操作继续时报告增量结果。 这些结果将存储在从 [ProgressChangedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs) 派生的类中并显示为此派生类中的属性。 你可以在 `ProgressChanged` 事件的事件处理程序中访问这些结果，就像访问 [ProgressPercentage](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs.progresspercentage) 属性一样。 如果有多个异步操作挂起，你可以使用 [UserState](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs.userstate) 属性来分辨出哪个操作在报告增量结果。



## 实现基于事件的异步模式

如果要编写的类有一些可能会带来明显延迟的操作，请考虑按照[基于事件的异步模式](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview)中的步骤操作，为它实现异步功能。

基于事件的异步模式提供了打包具有异步功能的类的标准化方式。 如果使用帮助程序类（如 [AsyncOperationManager](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperationmanager)）进行实现，类可以在任何应用模型（包括 ASP.NET、控制台应用和 Windows 窗体应用）下正常运行。

有关实现基于事件的异步模式的示例，请参阅[如何：实现支持基于事件的异步模式的组件](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern)。

对于简单的异步操作，可能会发现 [BackgroundWorker](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.backgroundworker) 组件非常适合。 若要详细了解 [BackgroundWorker](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.backgroundworker)，请参阅[如何：在后台运行操作](https://learn.microsoft.com/zh-cn/dotnet/desktop/winforms/controls/how-to-run-an-operation-in-the-background)。

以下列表介绍本主题中讨论的基于事件的异步模式的功能。

- 实现基于事件的异步模式的时机
- 命名异步方法
- 选择性地支持取消
- 选择性地支持 IsBusy 属性
- 选择性地为进度报告提供支持
- 选择性地为返回增量结果提供支持
- 处理方法中的 Out 和 Ref 参数

### 实现基于事件的异步模式的时机

请在以下情况下，考虑实现基于事件的异步模式：

- 类的客户端不需要适用于异步操作的 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 和 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 对象。也就是说，客户端需要生成轮询和 [WaitAll](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitall) 或 [WaitAny](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitany)。
- 你希望异步操作由客户端使用常见的事件/委托模型进行托管。

对于异步实现，任何操作都是候选项，但应优先考虑预计会产生较长延迟的操作。 最适合的操作是客户端在其中调用方法，并在完成时收到通知，无需进一步的干预。 其次是连续运行、定期向客户端通知进度、增量结果和状态更改的操作。

若要深入了解决定何时支持基于事件的异步模式，请参阅[决定何时实现基于事件的异步模式](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern)。

### 命名异步方法

对于要向其提供异步等效方法的每个同步方法 *MethodName*：

定义满足以下条件的 MethodNameAsync 方法：

- 返回 `void`。
- 采用与 *MethodName* 方法相同的参数。
- 接受多个调用。

（可选）定义与 MethodNameAsync 完全相同的 MethodNameAsync 重载，但要额外添加对象赋值参数（即 `userState`）。 如果已准备好管理方法的多个并发调用（在这种情况下，`userState` 值将传递回所有事件处理程序以区分方法的调用），可使用此方法。 也可以选择将其简单地作为存储用户状态以供以后检索的位置。

对于各个 MethodNameAsync 方法签名：

1. 在与方法相同的类中定义以下事件：

```C#
public event MethodNameCompletedEventHandler MethodNameCompleted;
```

2. 定义以下委托和 [AsyncCompletedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs)。 这些可能会在类本身之外、但在相同命名空间中定义。

   ```C#
   public delegate void MethodNameCompletedEventHandler(object sender,
       MethodNameCompletedEventArgs e);
   
   public class MethodNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
   {
       public MyReturnType Result { get; }
   }
   ```

   - 请确保 MethodNameCompletedEventArgs 类将它的成员公开为只读属性（而不是字段），因为字段会阻止数据绑定。
   - 请勿为不产生结果的方法定义任何派生自 [AsyncCompletedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs) 的类。 直接使用 [AsyncCompletedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs) 本身的实例即可。

> [!NOTE]
> 在可行且适当的情况下，重用委托和 [AsyncCompletedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs) 类型是完全可以接受的。 在这种情况下，命名会与方法名称不一致，因为给定委托和 [AsyncCompletedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs) 不限于单个方法。

### 选择性地支持取消

如果你的类将支持取消异步操作，则应向客户端公开取消（如下所述）。 定义取消支持之前，需要确定两点：

- 你的类（包括将来预计要添加的内容），是否只具有一个支持取消操作的异步操作？
- 支持取消的异步操作是否能支持多个挂起操作？ 也就是说，MethodNameAsync 方法是否需要使用 `userState` 参数？它是否允许在等待任何操作完成前执行多个调用？

使用下表中的两个问题的答案来确定取消方法的签名。

### C#

展开表

|                          | 支持多个并行操作                                | 每次一个操作                    |
| :----------------------- | :---------------------------------------------- | :------------------------------ |
| 整个类中具有一个异步操作 | `void MethodNameAsyncCancel(object userState);` | `void MethodNameAsyncCancel();` |
| 类中具有多个异步操作     | `void CancelAsync(object userState);`           | `void CancelAsync();`           |

如果定义了 `CancelAsync(object userState)` 方法，客户端在选择状态值时必须小心，以使其能够区分对象上调用的所有异步方法，而不仅仅是在单个异步方法的所有调用之间进行区分。

决定命名单一异步操作版本 MethodNameAsyncCancel 的依据是，能否在设计环境（如 Visual Studio 的 IntelliSense）中更轻松地发现方法。 这会对相关的成员进行分组，将与异步功能无关的其他成员区分开来。 如果预计可能在后续版本中添加其他异步操作，最好定义 `CancelAsync`。

请勿在同一类中定义上表中的多个方法。 这将毫无意义，或者会由于方法的泛滥而使类接口变得混乱。

通常，这些方法会立即返回，并且操作实际上可能会/无法取消。 在 MethodNameCompleted 事件的事件处理程序中，MethodNameCompletedEventArgs 对象包含 `Cancelled` 字段，客户端可使用此字段来确定是否取消了操作。

请遵守[实现基于事件的异步模式的最佳做法](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern)中所述的取消语义。

### 选择性地支持 IsBusy 属性

如果你的类不支持多个并发调用，请考虑公开 `IsBusy` 属性。 这样一来，开发人员可以确定能否运行 MethodNameAsync 方法，同时又不会捕获到 MethodNameAsync 方法抛出的异常。

请遵守[实现基于事件的异步模式的最佳做法](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern)中所述的 `IsBusy` 语义。

### 选择性地为进度报告提供支持

通常期望异步操作在其操作期间报告进度。 基于事件的异步模式提供了执行此操作的准则。

- 还可以选择性地定义由异步操作引发并在相应线程上调用的事件。 [ProgressChangedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs) 对象随附整数值进度指示器，量程预计在 0 到 100 之间。

- 按照以下规则命名此事件：

  - 如果类具有多个异步操作（或预期将来版本中会包括多个异步操作），则命名为 `ProgressChanged`；
  - MethodNameProgressChanged：如果类包含单一异步操作。

  该命名方法与命名取消方法（如“选择性地支持取消”部分所述）相同。

此事件应使用 [ProgressChangedEventHandler](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventhandler) 委托签名和 [ProgressChangedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs) 类。 或者，如果可以提供更多域专用进度指示器（例如，下载操作的读取字节数和总字节数），应定义 [ProgressChangedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs) 的派生类。

请注意，无论类支持多少个异步方法，都只有一个 `ProgressChanged` 或 MethodNameProgressChanged 事件。 客户端应使用传递给 MethodNameAsync 方法的 `userState` 对象，以区分多个并发操作的进度更新。

可能出现多个操作支持进度，并且每个操作返回不同的进度指示器的情况。 在这种情况下，不合适支持单个 `ProgressChanged` 事件，你可能需要考虑支持多个 `ProgressChanged` 事件。 在这种情况下，对每个 MethodNameAsync 方法使用 MethodNameProgressChanged 命名模式。

请遵守[实现基于事件的异步模式的最佳做法](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern)中所述的进度报告语义。

### 选择性地为返回增量结果提供支持

有时异步操作可以在完成之前返回增量结果。 可以通过多种方式支持此方案。 下面是一些示例。

#### 单一操作类

如果你的类仅支持单一异步操作，并且能够返回增量结果，则可以：

- 将 [ProgressChangedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs) 类型扩展为包含增量结果数据，并定义包含此扩展数据的 MethodNameProgressChanged 事件。
- 若有要报告的增量结果，抛出此 MethodNameProgressChanged 事件。

此解决方案特别适用于单一异步操作类，因为发生的同一事件可以对“所有操作”返回增量结果，与 MethodNameProgressChanged 事件一样。

#### 使用同类增量结果的多操作类

在这种情况下，你的类支持多个异步方法，每个方法都能够返回增量结果，并且这些增量结果具有相同的数据类型。

请遵循上述适用于单一操作类的模型，因为同一 [EventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.eventargs) 结构适用于所有增量结果。 定义 `ProgressChanged` 事件，而不是 MethodNameProgressChanged 事件，因为它适用于多个异步方法。

#### 使用不同类增量结果的多操作类

如果你的类支持多个异步方法，每个方法返回不同类型的数据，则应该：

- 将增量结果报告与进度报告分开。
- 单独定义针对每个异步方法有适当 [EventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.eventargs) 的 MethodNameProgressChanged 事件，以处理此方法的增量结果数据。

按照[实现基于事件的异步模式的最佳做法](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern)所述，在适当线程上调用事件处理程序。

###  处理方法中的 Out 和 Ref 参数

虽然一般情况下，建议不要在 .NET 中使用 `out` 和 `ref`，但以下是使用它们时要遵循的规则：

给定同步方法 *MethodName*：

- MethodName 的 `out` 参数不应为 MethodNameAsync 的一部分。 它们应是 MethodNameCompletedEventArgs 的一部分，与 MethodName 中的相当参数同名（除非有更合适的名称）。
- MethodName 的 `ref` 参数应显示为 MethodNameAsync 的一部分，并显示为 MethodNameCompletedEventArgs 的一部分，与 MethodName 中的相当参数同名（除非有更合适的名称）。

例如，给定：

```C#
public int MethodName(string arg1, ref string arg2, out string arg3);
```

异步方法及其 [AsyncCompletedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs) 类如下所示：

```C#
public void MethodNameAsync(string arg1, string arg2);

public class MethodNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
{
    public int Result { get; };
    public string Arg2 { get; };
    public string Arg3 { get; };
}
```



## 实现基于事件的异步模式的最佳做法

基于事件的异步模式提供了一种在类中使用熟悉的事件和委托语义公开异步行为的有效方法。 若要实现基于事件的异步模式，你需要遵循某些特定的行为要求。 以下部分描述了在你实现遵循基于事件的异步模式的类时应该考虑的要求和准则。

有关概述，请参阅[实现基于事件的异步模式](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern)。

### 必需的行为保证

若要实现基于事件的异步模式，你必须提供一些保证来确保类的行为正确且类的客户端能够依赖这种行为。

#### Completion

操作成功完成、出错或取消时，始终应调用 *MethodName*Completed 事件处理程序。 任何情况下，应用程序都不应遇到这样的情况：应用程序保持空闲状态，而操作却一直不能完成。 此规则的例外情况是：异步操作本身设计为永不完成。

#### 已完成的事件和 EventArgs

针对每个单独的 *MethodName*Async 方法，请应用以下设计要求：

- 在与该方法相同的类上定义 *MethodName*Completed 事件。

- 为派生自 [AsyncCompletedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs) 类的 *MethodName*Completed 事件定义一个 [EventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.eventargs) 类和随附委托。 默认类名应采用 *MethodName*CompletedEventArgs 形式。

- 确保 [EventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.eventargs) 类特定于 [EventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.eventargs) 方法的返回值。 在使用 [EventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.eventargs) 类时，切勿要求开发人员强制转换结果。

  下面的代码示例分别演示了此项设计要求的合理实现和错误实现。

```C#
// Good design
private void Form1_MethodNameCompleted(object sender, xxxCompletedEventArgs e)
{
    DemoType result = e.Result;
}

// Bad design
private void Form1_MethodNameCompleted(object sender, MethodNameCompletedEventArgs e)
{
    DemoType result = (DemoType)(e.Result);
}
```

- 不要为返回 [EventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.eventargs) 的返回方法定义 `void` 类。 而应使用 [AsyncCompletedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs) 类的实例。
- 应务必始终抛出 *MethodName*Completed 事件。 成功完成、出错或者取消时应引发此事件。 任何情况下，应用程序都不应遇到这样的情况：应用程序保持空闲状态，而操作却一直不能完成。
- 确保可以捕获异步操作中发生的任何异常并将捕获的异常分配给 [Error](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs.error) 属性。
- 如果完成任务时出现错误，其结果应当不可访问。 当 [Error](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs.error) 属性不为 `null` 时，确保访问 [EventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.eventargs) 结构中的任何属性都会引发异常。 使用 [RaiseExceptionIfNecessary](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs.raiseexceptionifnecessary) 方法来执行此验证。
- 将超时建模为错误。 如果发生超时，应抛出 *MethodName*Completed 事件，并将 [TimeoutException](https://learn.microsoft.com/zh-cn/dotnet/api/system.timeoutexception) 分配给 [Error](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs.error) 属性。
- 如果类支持多个并发调用，应确保 *MethodName*Completed 事件包含相应的 `userSuppliedState` 对象。
- 应确保在应用生命周期中适时对相应线程抛出 *MethodName*Completed 事件。 有关更多信息，请参见“线程处理和上下文”部分。

#### 同时执行操作

- 如果类支持多个并发调用，应让开发人员可以单独跟踪各个调用，具体操作是定义 *MethodName*Async 重载，此重载需要使用对象赋值状态参数或任务 ID（名为 `userSuppliedState`）。 此参数应始终是 *MethodName*Async 方法签名中的最后一个参数。
- 如果类定义了需要使用对象赋值状态参数或任务 ID 的 *MethodName*Async 重载，应务必使用相应任务 ID 跟踪操作的生存期，并将它 返回给完成事件处理器。 有一些用来提供帮助的帮助器类。 有关并发管理的详细信息，请参阅[如何：实现支持基于事件的异步模式的组件](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern)。
- 如果类定义了不使用状态参数的 *MethodName*Async 方法，且它不支持多个并发调用，则应确保在先前 *MethodName*Async 调用完成前，只要尝试调用 *MethodName*Async 都会导致 [InvalidOperationException](https://learn.microsoft.com/zh-cn/dotnet/api/system.invalidoperationexception) 抛出。
- 一般来说，如果多次调用不使用 `userSuppliedState` 参数的 *MethodName*Async 方法，导致多个未结操作出现，不得抛出异常。 如果类无法显式处理这种情况，将引发异常，但可假定开发人员能够处理多个不可区分回调。



#### 访问结果

- 如果在执行异步操作期间出现错误，其结果应当不可访问。 确保在 [AsyncCompletedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs) 不为 [Error](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs.error) 时访问 `null` 中的任何属性都会引发由 [Error](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs.error) 引用的异常。 [AsyncCompletedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs) 类为达到此目的提供了 [RaiseExceptionIfNecessary](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs.raiseexceptionifnecessary) 方法。
- 确保访问结果的任何尝试都将引发 [InvalidOperationException](https://learn.microsoft.com/zh-cn/dotnet/api/system.invalidoperationexception)，指出该操作已被取消。 使用 [AsyncCompletedEventArgs.RaiseExceptionIfNecessary](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs.raiseexceptionifnecessary) 方法来执行此验证。

#### 进度报告

- 如有可能，支持进度报告。 在开发人员使用你的类时，这使他们能够提供更好的应用程序用户体验。
- 如果实现 ProgressChanged 或 *MethodName*ProgressChanged 事件，应确保在抛出特定异步操作的 *MethodName*Completed 事件后，不会对此操作抛出所实现的事件。
- 如果正在填充标准的 [ProgressChangedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs)，则请确保始终能够将 [ProgressPercentage](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs.progresspercentage) 解释为一个百分比。 该百分比不必是一个精确值，但它应表示为百分数的形式。 如果你的进度报告指标不能是一个百分比，请从 [ProgressChangedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs) 类中派生一个类并将 [ProgressPercentage](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs.progresspercentage) 保留为 0。 避免使用非百分比的报告指标。
- 请确保在应用程序生命周期中的适当时间在适当的线程上引发了 `ProgressChanged` 事件。 有关更多信息，请参见“线程处理和上下文”部分。

#### IsBusy 实现

- 如果你的类支持多个并发调用，则不要公开 `IsBusy` 属性。 例如，XML Web services 代理不会公开 `IsBusy` 属性，因为它们支持异步方法的多个并发调用。
- 在调用 *MethodName*Async 方法后，且在抛出 *MethodName*Completed 事件前，`IsBusy` 属性应返回 `true`。 否则，它应返回 `false`。 [BackgroundWorker](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.backgroundworker) 和 [WebClient](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.webclient) 组件是公开 `IsBusy` 属性的类的示例。



#### 取消

- 如有可能，支持取消。 在开发人员使用你的类时，这使他们能够提供更好的应用程序用户体验。
- 在发生取消时，设置 [Cancelled](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs.cancelled) 对象中的 [AsyncCompletedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs) 标志。
- 确保访问结果的任何尝试都将引发 [InvalidOperationException](https://learn.microsoft.com/zh-cn/dotnet/api/system.invalidoperationexception)，指出该操作已被取消。 使用 [AsyncCompletedEventArgs.RaiseExceptionIfNecessary](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs.raiseexceptionifnecessary) 方法来执行此验证。
- 请确保对取消方法发出的调用始终能够成功返回，而且从不引发异常。 一般来说，客户端不会得到关于在任何给定时间是否真正可取消某个操作的通知，也不会得到关于以前发出的取消是否已经成功的通知。 不过，应用程序在取消成功时总能得到通知，因为应用程序参与了完成状态。
- 取消操作时，应抛出 *MethodName*Completed 事件。

####  错误和异常

- 捕获所有发生在异步操作中的异常并将 [AsyncCompletedEventArgs.Error](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asynccompletedeventargs.error) 属性的值设置为该异常。



#### 线程处理和上下文

为了使类正确运行，应当使用给定应用程序模型（包括 ASP.NET 和 Windows 窗体应用程序）的适当线程或上下文调用客户端事件处理程序，这一点很重要。 我们提供了两个重要的帮助器类，以确保你的异步类在任何应用程序模型中都能正确运行，这两个帮助器类是 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation) 和 [AsyncOperationManager](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperationmanager)。

[AsyncOperationManager](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperationmanager) 提供了 [CreateOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperationmanager.createoperation) 方法，该方法会返回一个 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation)。 *MethodName*Async 方法调用 [CreateOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperationmanager.createoperation)，且类使用返回的 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation) 跟踪异步任务的生存期。

若要将进程、增量结果和完成情况报告给客户端，请调用 [Post](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation.post) 上的 [OperationCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation.operationcompleted) 和 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation) 方法。 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation) 负责将对客户端事件处理程序的调用封送到合适的线程或上下文。

> [!NOTE]
> 如果你明确想违反应用程序模型的策略，但仍想获得使用基于事件的异步模式的其他好处，则你可以避开这些规则。 例如，你可能希望在 Windows 窗体中进行操作的某个类是自由线程类。 只要开发人员了解隐含的限制，你就可以创建自由线程类。 控制台应用程序不会同步 [Post](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation.post) 调用的执行。 这会导致按错误的顺序引发 `ProgressChanged` 事件。 如果希望序列化 [Post](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation.post) 调用的执行，请实现并安装 [System.Threading.SynchronizationContext](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.synchronizationcontext) 类。

若要详细了解如何使用 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation) 和 [AsyncOperationManager](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperationmanager) 启用异步操作，请参阅[AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation)。

### 指南

- 理论上，方法调用与方法调用之间应是相互独立的。 你应当避免在使用调用时使用共享资源。 如果要在不同调用之间共享资源，则你需要在你的实现中提供一个适当的同步机制。
- 建议不要进行需要客户端实现同步的设计。 例如，你可以使用一个异步方法将全局静态对象作为参数来接收；这类方法的多个并发调用可能会导致数据损坏或死锁。
- 如果你使用多个调用重载（签名中的 `userState`）实现方法，你的类将需要管理由一系列用户状态、任务 ID 及其相应的挂起操作构成的一个集合。 应当使用 `lock` 区域保护此集合，因为各种调用都会在此集合中添加和移除 `userState` 对象。
- 请考虑在可行且适当的情况下，重新使用 `CompletedEventArgs` 类。 在这种情况下，命名和方法名不一致，因为给定的委托和 [EventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.eventargs) 类型并不会与单独某个方法联系在一起。 不过，强制开发人员对从 [EventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.eventargs) 上的属性检索的值进行强制转换，是绝对不可取的。
- 如果你正在创建自 [Component](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.component) 派生的类，请不要实现和安装你自己的 [SynchronizationContext](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.synchronizationcontext) 类。 所使用的 [SynchronizationContext](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.synchronizationcontext) 由应用程序模型而不是组件控制。
- 当你使用任何形式的多线程时，都有可能会遇到非常严重且复杂的 Bug。 在实现任何使用多线程处理的解决方案之前，请参阅[托管线程处理最佳做法](https://learn.microsoft.com/zh-cn/dotnet/standard/threading/managed-threading-best-practices)。





## 确定何时实现基于事件的异步模式

基于事件的异步模式可用于公开类的异步行为。 通过引入此模式，.NET 定义了下面两种用于公开异步行为的模式：基于 [System.IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 接口的异步模式和基于事件的模式。 本文介绍了何时适合实现这两种模式。

若要详细了解如何使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 接口进行异步编程，请参阅[异步编程模型 (APM)](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm)。

### 一般原则

一般来说，应尽量使用基于事件的异步模式公开异步功能。 不过，基于事件的模式无法满足一些要求。 在这种情况下，除了基于事件的模式外，可能还需要实现 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。

> [!NOTE]
> 实现了 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式但没有实现基于事件的模式，这种情况很少见。

### 准则

下面列出了应在何时实现基于事件的异步模式的相关指南：

- 将基于事件的模式用作公开类的异步行为的默认 API。
- 如果类主要用于客户端应用（例如，Windows 窗体），请勿公开 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。
- 仅在需要满足特定要求时，才公开 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。 例如，为了与现有 API 兼容，可能需要公开 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。
- 请勿在不公开基于事件的模式的情况下公开 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。
- 如果必须公开 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式，请以高级选项的形式这样做。 例如，如果生成代理对象，默认生成的是基于事件的模式，并含用于生成 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式的选项。
- 在 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式实现的基础之上生成基于事件的模式实现。
- 避免对相同的类公开基于事件的模式和 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。 请对“高级”类公开基于事件的模式，并对“低级”类公开 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。 例如，比较 [WebClient](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.webclient) 组件上基于事件的模式与 [HttpRequest](https://learn.microsoft.com/zh-cn/dotnet/api/system.web.httprequest) 类上的 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。
  - 出于兼容性需要，可以对相同的类公开基于事件的模式和 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。 例如，如果已释放使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式的 API，需要保留 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式，以实现向后兼容性。
  - 如果生成的对象模型复杂性远远超过分离实现的好处，请对相同的类公开基于事件的模式和 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。 对一个类公开两种模式优于避免公开基于事件的模式。
  - 如果必须对一个类公开基于事件的模式和 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式，请将 [EditorBrowsableAttribute](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.editorbrowsableattribute) 设置为 [Advanced](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.editorbrowsablestate#system-componentmodel-editorbrowsablestate-advanced)，以将 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式实现标记为高级功能。 这会指示设计环境（如 Visual Studio IntelliSense）不显示 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 属性和方法。 这些属性和方法仍完全可用，这样做只是为了让使用 IntelliSense 的开发人员对 API 更加明确。

### 除了基于事件的模式外还公开 IAsyncResult 模式的条件

虽然基于事件的异步模式在上述情况下有许多优点，但也有一些缺点。如果性能是最重要的要求，应注意这些缺点。

[IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式比基于事件的模式更适用 的情况有三种：

- 对 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 阻止等待操作
- 对多个 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 对象阻止等待操作
- 对 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 轮询完成状态

虽然可以使用基于事件的模式来处理这些情况，但这样做比使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式更不方便。

开发人员经常对性能要求通常很高的服务使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。 例如，轮询完成状态就是一种高性能服务器技术。

此外，基于事件的模式的效率低于 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式，因为前者创建的对象更多（尤其是 [EventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.eventargs)），并且跨线程同步。

下面列出了一些在决定使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式时要遵循的建议：

- 仅在特别需要对 [WaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle) 或[IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 对象的支持时，才公开 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。
- 仅在有使用 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式的现有 API 时，才公开 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。
- 如果有基于 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式的现有 API，还请考虑在下一个版本中公开基于事件的模式。
- 仅在有高性能要求，且已验证无法通过基于事件的模式满足这些要求，但可以通过 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式满足时，才公开 [IAsyncResult](https://learn.microsoft.com/zh-cn/dotnet/api/system.iasyncresult) 模式。





## 如何：实现支持基于事件的异步模式的组件

若要编写的类有一些可能会带来明显延迟的操作，请考虑按照[基于事件的异步模式概述](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview)中的步骤操作，为它实现异步功能。

本演练展示了如何创建实现基于事件的异步模式的组件。 此组件是使用 [System.ComponentModel](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel) 命名空间中的帮助程序类进行实现，这可确保它在任何应用模型（包括 ASP.NET、控制台应用和 Windows 窗体应用）下都能正常运行。 也可以使用 [PropertyGrid](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.propertygrid) 控件和自己的自定义设计器来设计此组件。

本演练使用异步计算质数的应用。 应用有主用户界面 (UI) 线程，以及用于每次质数计算的线程。 尽管测试大数字是否为质数需要花费很长时间，但主 UI 线程不会被此延迟中断，并且窗体在计算期间仍为响应式。 不仅可以同时运行计算（数量不限），还能选择性地取消挂起的计算。

本演练涉及以下任务：

- 创建组件
- 定义公共异步事件和委托
- 定义专用委托
- 实现公共事件
- 实现完成方法
- 实现工作方法
- 实现启动和取消方法

若要将本主题中的代码复制为一个代码清单，请参阅[如何：实现基于事件的异步模式的客户端](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/how-to-implement-a-client-of-the-event-based-asynchronous-pattern)。

### 创建组件

第一步是，创建实现基于事件的异步模式的组件。



#### 创建组件的具体步骤

- 创建继承自 [Component](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.component) 的类 `PrimeNumberCalculator`。



### 定义公共异步事件和委托

组件使用事件与客户端进行通信。 *MethodName***Completed** 事件预警客户端注意异步任务完成，*MethodName***ProgressChanged** 事件向客户端告知异步任务的进度。



#### 若要定义组件客户端的异步事件，请执行以下步骤：

1. 在文件顶部，导入 [System.Threading](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading) 和 [System.Collections.Specialized](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.specialized) 命名空间。

   ```C#
   using System;
   using System.Collections;
   using System.Collections.Specialized;
   using System.ComponentModel;
   using System.Data;
   using System.Drawing;
   using System.Globalization;
   using System.Threading;
   using System.Windows.Forms;
   ```

2. 在 `PrimeNumberCalculator` 类定义前面，声明进度和完成事件的委托。

   ```C#
   public delegate void ProgressChangedEventHandler(
       ProgressChangedEventArgs e);
   
   public delegate void CalculatePrimeCompletedEventHandler(
       object sender,
       CalculatePrimeCompletedEventArgs e);
   ```

3. 在 `PrimeNumberCalculator` 类定义中，声明向客户端报告进度和完成事件的事件。

   ```C#
   public event ProgressChangedEventHandler ProgressChanged;
   public event CalculatePrimeCompletedEventHandler CalculatePrimeCompleted;
   ```

   

4. 在 `PrimeNumberCalculator` 类定义后面，派生 `CalculatePrimeCompletedEventArgs` 类，向 `CalculatePrimeCompleted` 事件的客户端事件处理程序报告每次计算的结果。 除了 `AsyncCompletedEventArgs` 属性外，客户端还可以使用此类确定测试的数字是什么、数字是否为质数，以及第一个除数是什么（如果不是质数的话）。

   ```C#
   public class CalculatePrimeCompletedEventArgs :
       AsyncCompletedEventArgs
   {
       private int numberToTestValue = 0;
       private int firstDivisorValue = 1;
       private bool isPrimeValue;
   
       public CalculatePrimeCompletedEventArgs(
           int numberToTest,
           int firstDivisor,
           bool isPrime,
           Exception e,
           bool canceled,
           object state) : base(e, canceled, state)
       {
           this.numberToTestValue = numberToTest;
           this.firstDivisorValue = firstDivisor;
           this.isPrimeValue = isPrime;
       }
   
       public int NumberToTest
       {
           get
           {
               // Raise an exception if the operation failed or
               // was canceled.
               RaiseExceptionIfNecessary();
   
               // If the operation was successful, return the
               // property value.
               return numberToTestValue;
           }
       }
   
       public int FirstDivisor
       {
           get
           {
               // Raise an exception if the operation failed or
               // was canceled.
               RaiseExceptionIfNecessary();
   
               // If the operation was successful, return the
               // property value.
               return firstDivisorValue;
           }
       }
   
       public bool IsPrime
       {
           get
           {
               // Raise an exception if the operation failed or
               // was canceled.
               RaiseExceptionIfNecessary();
   
               // If the operation was successful, return the
               // property value.
               return isPrimeValue;
           }
       }
   }
   ```

### ## 检查点 1

此时，可以生成组件。

#### 测试组件的具体步骤

- 编译组件。

  将看到下面两个编译器警告：

  控制台复制

  ```console
  warning CS0067: The event 'AsynchronousPatternExample.PrimeNumberCalculator.ProgressChanged' is never used  
  warning CS0067: The event 'AsynchronousPatternExample.PrimeNumberCalculator.CalculatePrimeCompleted' is never used  
  ```

  这些警告会在下一部分中得到清除。

###  定义专用委托

`PrimeNumberCalculator` 组件的异步特性是通过特殊的 [SendOrPostCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.sendorpostcallback) 委托在内部进行实现。 [SendOrPostCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.sendorpostcallback) 表示对 [ThreadPool](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 线程执行的回调方法。 回调方法必须有需要使用单个 [Object](https://learn.microsoft.com/zh-cn/dotnet/api/system.object) 类型参数的签名。也就是说，需要在包装类中的各委托之间传递状态。 有关详细信息，请参阅 [SendOrPostCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.sendorpostcallback)。

#### 若要实现组件的内部异步行为，请执行以下操作：

1. 在 `PrimeNumberCalculator` 类中声明并创建 [SendOrPostCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.sendorpostcallback) 委托。 在 `InitializeDelegates` 实用工具方法中创建 [SendOrPostCallback](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.sendorpostcallback) 对象。

   需要使用两个委托：一个用于向客户端报告进度事件，另一个用于向客户端报告完成事件。

   C#复制

   ```csharp
   private SendOrPostCallback onProgressReportDelegate;
   private SendOrPostCallback onCompletedDelegate;
   ```

   C#复制

   ```csharp
   protected virtual void InitializeDelegates()
   {
       onProgressReportDelegate =
           new SendOrPostCallback(ReportProgress);
       onCompletedDelegate =
           new SendOrPostCallback(CalculateCompleted);
   }
   ```

2. 在组件的构造函数中调用 `InitializeDelegates` 方法。

   C#复制

   ```csharp
   public PrimeNumberCalculator()
   {
       InitializeComponent();
   
       InitializeDelegates();
   }
   ```

3. 在 `PrimeNumberCalculator` 类中声明委托，以处理实际要异步完成的工作。 此委托包装用于测试数字是否为质数的工作方法。 此委托需要使用 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation) 参数，用于跟踪异步操作的生存期。

   C#复制

   ```csharp
   private delegate void WorkerEventHandler(
       int numberToCheck,
       AsyncOperation asyncOp);
   ```

4. 创建一个集合，用于管理挂起的异步操作的生存期。 客户端需要通过一种途径，跟踪已执行和完成的操作。若要执行这样的跟踪，客户端必须在调用异步方法时，传递唯一令牌或任务 ID。 `PrimeNumberCalculator` 组件必须跟踪所有调用，具体方法是将任务 ID 与其对应的调用相关联。 如果客户端传递的任务 ID 不唯一，`PrimeNumberCalculator` 组件必须抛出异常。

   `PrimeNumberCalculator` 组件使用特殊的集合类 [HybridDictionary](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.specialized.hybriddictionary) 跟踪任务 ID。 在类定义中，创建名为 `userStateToLifetime` 的 [HybridDictionary](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.specialized.hybriddictionary)。

   C#复制

   ```csharp
   private HybridDictionary userStateToLifetime =
       new HybridDictionary();
   ```



### 实现公共事件

实现基于事件的异步模式的组件使用事件与客户端进行通信。 这些事件在 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation) 类的相助下对适当的线程调用。

#### 若要向组件的客户端抛出事件，请执行以下操作：

1. 实现公共事件，以向客户端报告事件。 需要实现两个事件，一个用于报告进度事件，另一个用于报告完成事件。

   C#复制

   ```csharp
   // This method is invoked via the AsyncOperation object,
   // so it is guaranteed to be executed on the correct thread.
   private void CalculateCompleted(object operationState)
   {
       CalculatePrimeCompletedEventArgs e =
           operationState as CalculatePrimeCompletedEventArgs;
   
       OnCalculatePrimeCompleted(e);
   }
   
   // This method is invoked via the AsyncOperation object,
   // so it is guaranteed to be executed on the correct thread.
   private void ReportProgress(object state)
   {
       ProgressChangedEventArgs e =
           state as ProgressChangedEventArgs;
   
       OnProgressChanged(e);
   }
   
   protected void OnCalculatePrimeCompleted(
       CalculatePrimeCompletedEventArgs e)
   {
       if (CalculatePrimeCompleted != null)
       {
           CalculatePrimeCompleted(this, e);
       }
   }
   
   protected void OnProgressChanged(ProgressChangedEventArgs e)
   {
       if (ProgressChanged != null)
       {
           ProgressChanged(e);
       }
   }
   ```



### 实现完成方法

完成委托是在异步操作最终成功完成、出错或取消时，由基础的自由线程异步行为调用的方法。 此调用发生在任意线程上。

在此方法中，客户端任务 ID 从唯一客户端令牌的内部集合中删除。 另外，此方法还对相应的 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation) 调用 [PostOperationCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation.postoperationcompleted)方法，结束特定异步操作的生存期。 此调用对适用于应用模型的线程抛出完成事件。 调用 [PostOperationCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation.postoperationcompleted) 后，便无法再使用此 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation) 实例，随后只要尝试使用它，就会导致异常抛出。

`CompletionMethod` 签名必须保留描述异步操作结果所需的全部状态。 它保留以下状态：此异步操作测试的数字是什么、数字是否为质数，以及第一个除数的值是什么（如果不是质数的话）。 此外，它还保留描述所发生的任何异常的状态，以及与此任务对应的 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation)。



#### 若要完成异步操作，请执行以下操作：

- 实现完成方法。 此方法需要使用六个参数，用于填充通过客户端的 `CalculatePrimeCompletedEventHandler` 返回到客户端的 `CalculatePrimeCompletedEventArgs`。 它还从内部集合中删除客户端的任务 ID 令牌，并通过调用 [PostOperationCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation.postoperationcompleted) 结束异步操作的生存期。 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation) 封送对适用于应用模型的线程或上下文执行的调用。

  C#复制

  ```csharp
  // This is the method that the underlying, free-threaded
  // asynchronous behavior will invoke.  This will happen on
  // an arbitrary thread.
  private void CompletionMethod(
      int numberToTest,
      int firstDivisor,
      bool isPrime,
      Exception exception,
      bool canceled,
      AsyncOperation asyncOp )
  
  {
      // If the task was not previously canceled,
      // remove the task from the lifetime collection.
      if (!canceled)
      {
          lock (userStateToLifetime.SyncRoot)
          {
              userStateToLifetime.Remove(asyncOp.UserSuppliedState);
          }
      }
  
      // Package the results of the operation in a
      // CalculatePrimeCompletedEventArgs.
      CalculatePrimeCompletedEventArgs e =
          new CalculatePrimeCompletedEventArgs(
          numberToTest,
          firstDivisor,
          isPrime,
          exception,
          canceled,
          asyncOp.UserSuppliedState);
  
      // End the task. The asyncOp object is responsible
      // for marshaling the call.
      asyncOp.PostOperationCompleted(onCompletedDelegate, e);
  
      // Note that after the call to OperationCompleted,
      // asyncOp is no longer usable, and any attempt to use it
      // will cause an exception to be thrown.
  }
  ```



### 检查点 2

此时，可以生成组件。



#### 测试组件的具体步骤

- 编译组件。

  将看到下面的一个编译器警告：

  控制台复制

  ```console
  warning CS0169: The private field 'AsynchronousPatternExample.PrimeNumberCalculator.workerDelegate' is never used  
  ```

  此警告会在下一部分中得到解析。

### 实现工作方法

至此，已实现 `PrimeNumberCalculator` 组件的支持异步代码。 现在，可以实现执行实际工作的代码。 将实现以下三个方法：`CalculateWorker`、`BuildPrimeNumberList` 和 `IsPrime`。 `BuildPrimeNumberList` 和 `IsPrime` 共同构成了著名的埃拉托斯特尼筛法，通过在测试数字的平方根范围内查找所有质数，确定数字是否为质数。 如果使用这种方法没有找到任何除数，表明测试数字为质数。

如果此组件旨在最大限度地提高效率，便会记住对不同测试数字执行各种调用时发现的所有质数。 它还会检查是否有最简单的除数（如 2、3 和 5）。 虽然此示例旨在展示如何异步执行非常耗时的操作，但这些优化是留给大家练练手的。

`CalculateWorker` 方法包装在委托中，通过调用 `BeginInvoke` 进行异步调用。

> [!NOTE]
> 进度事件报告是在 `BuildPrimeNumberList` 方法中实现。 在快速运行的计算机上，`ProgressChanged` 事件可能会快速连续抛出。 对其抛出这些事件的客户端线程必须能够处理这种情况。 消息可能会像洪水般涌入用户界面代码，导致代码无法不断更新，继而导致无响应。 有关处理这种情况的示例用户界面，请参阅[如何：实现基于事件的异步模式的客户端](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/how-to-implement-a-client-of-the-event-based-asynchronous-pattern)。



#### 若要异步执行质数计算，请执行以下操作：

1. 实现 `TaskCanceled` 实用工具方法。 此方法检查任务生存期集合中是否有给定的任务 ID；如果找不到任务 ID，就会返回 `true`。

   C#复制

   ```csharp
   // Utility method for determining if a
   // task has been canceled.
   private bool TaskCanceled(object taskId)
   {
       return( userStateToLifetime[taskId] == null );
   }
   ```

2. 实现 `CalculateWorker` 方法。 它需要使用下面两个参数：要测试的数字和 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation)。

   C#复制

   ```csharp
   // This method performs the actual prime number computation.
   // It is executed on the worker thread.
   private void CalculateWorker(
       int numberToTest,
       AsyncOperation asyncOp)
   {
       bool isPrime = false;
       int firstDivisor = 1;
       Exception e = null;
   
       // Check that the task is still active.
       // The operation may have been canceled before
       // the thread was scheduled.
       if (!TaskCanceled(asyncOp.UserSuppliedState))
       {
           try
           {
               // Find all the prime numbers up to
               // the square root of numberToTest.
               ArrayList primes = BuildPrimeNumberList(
                   numberToTest,
                   asyncOp);
   
               // Now we have a list of primes less than
               // numberToTest.
               isPrime = IsPrime(
                   primes,
                   numberToTest,
                   out firstDivisor);
           }
           catch (Exception ex)
           {
               e = ex;
           }
       }
   
       //CalculatePrimeState calcState = new CalculatePrimeState(
       //        numberToTest,
       //        firstDivisor,
       //        isPrime,
       //        e,
       //        TaskCanceled(asyncOp.UserSuppliedState),
       //        asyncOp);
   
       //this.CompletionMethod(calcState);
   
       this.CompletionMethod(
           numberToTest,
           firstDivisor,
           isPrime,
           e,
           TaskCanceled(asyncOp.UserSuppliedState),
           asyncOp);
   
       //completionMethodDelegate(calcState);
   }
   ```

3. 实现 `BuildPrimeNumberList`。 它需要使用下面两个参数：要测试的数字和 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation)。 此方法使用 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation) 报告进度和增量结果。 这可确保对适用于应用模型的线程或上下文调用客户端的事件处理程序。 如果 `BuildPrimeNumberList` 找到了质数，它会将此作为增量结果，报告给 `ProgressChanged` 事件的客户端事件处理程序。 为此，必须使用派生自 [ProgressChangedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs) 的类 `CalculatePrimeProgressChangedEventArgs`，其中新增有一个属性，即 `LatestPrimeNumber`。

   `BuildPrimeNumberList` 方法还会定期调用 `TaskCanceled` 方法，并在此方法返回 `true` 时退出。

   C#复制

   ```csharp
   // This method computes the list of prime numbers used by the
   // IsPrime method.
   private ArrayList BuildPrimeNumberList(
       int numberToTest,
       AsyncOperation asyncOp)
   {
       ProgressChangedEventArgs e = null;
       ArrayList primes = new ArrayList();
       int firstDivisor;
       int n = 5;
   
       // Add the first prime numbers.
       primes.Add(2);
       primes.Add(3);
   
       // Do the work.
       while (n < numberToTest &&
              !TaskCanceled( asyncOp.UserSuppliedState ) )
       {
           if (IsPrime(primes, n, out firstDivisor))
           {
               // Report to the client that a prime was found.
               e = new CalculatePrimeProgressChangedEventArgs(
                   n,
                   (int)((float)n / (float)numberToTest * 100),
                   asyncOp.UserSuppliedState);
   
               asyncOp.Post(this.onProgressReportDelegate, e);
   
               primes.Add(n);
   
               // Yield the rest of this time slice.
               Thread.Sleep(0);
           }
   
           // Skip even numbers.
           n += 2;
       }
   
       return primes;
   }
   ```

4. 实现 `IsPrime`。 它需要使用下面三个参数：已知质数列表、要测试的数字，以及找到的第一个除数的输出参数。 它根据质数列表确定测试数字是否为质数。

   C#复制

   ```csharp
   // This method tests n for primality against the list of
   // prime numbers contained in the primes parameter.
   private bool IsPrime(
       ArrayList primes,
       int n,
       out int firstDivisor)
   {
       bool foundDivisor = false;
       bool exceedsSquareRoot = false;
   
       int i = 0;
       int divisor = 0;
       firstDivisor = 1;
   
       // Stop the search if:
       // there are no more primes in the list,
       // there is a divisor of n in the list, or
       // there is a prime that is larger than
       // the square root of n.
       while (
           (i < primes.Count) &&
           !foundDivisor &&
           !exceedsSquareRoot)
       {
           // The divisor variable will be the smallest
           // prime number not yet tried.
           divisor = (int)primes[i++];
   
           // Determine whether the divisor is greater
           // than the square root of n.
           if (divisor * divisor > n)
           {
               exceedsSquareRoot = true;
           }
           // Determine whether the divisor is a factor of n.
           else if (n % divisor == 0)
           {
               firstDivisor = divisor;
               foundDivisor = true;
           }
       }
   
       return !foundDivisor;
   }
   ```

5. 从 [ProgressChangedEventArgs](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.progresschangedeventargs) 派生 `CalculatePrimeProgressChangedEventArgs`。 必须有此类，才能向 `ProgressChanged` 事件的客户端事件处理程序报告增量结果。 它新增有一个属性，即 `LatestPrimeNumber`。

   C#复制

   ```csharp
   public class CalculatePrimeProgressChangedEventArgs :
           ProgressChangedEventArgs
   {
       private int latestPrimeNumberValue = 1;
   
       public CalculatePrimeProgressChangedEventArgs(
           int latestPrime,
           int progressPercentage,
           object userToken) : base( progressPercentage, userToken )
       {
           this.latestPrimeNumberValue = latestPrime;
       }
   
       public int LatestPrimeNumber
       {
           get
           {
               return latestPrimeNumberValue;
           }
       }
   }
   ```



### 检查点 3

此时，可以生成组件。



#### 测试组件的具体步骤

- 编译组件。

  剩下要编写的就是，异步操作的启动和取消方法，即 `CalculatePrimeAsync` 和 `CancelAsync`。

### 实现启动和取消方法

若要对它自己的线程启动工作方法，请对包装方法的委托调用 `BeginInvoke`。 若要管理特定异步操作的生存期，请对 [AsyncOperationManager](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperationmanager) 帮助程序类调用 [CreateOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperationmanager.createoperation) 方法。 这会返回 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation)，将对客户端事件处理程序的调用封送到适当的线程或上下文。

若要取消特定挂起操作，请对相应的 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation) 调用 [PostOperationCompleted](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation.postoperationcompleted)。 这样一来，可以结束操作，随后只要调用 [AsyncOperation](https://learn.microsoft.com/zh-cn/dotnet/api/system.componentmodel.asyncoperation) 都会导致异常抛出。

#### 若要实现启动和取消功能，请执行以下操作：

1. 实现 `CalculatePrimeAsync` 方法。 请确保相对于表示当前挂起任务的所有令牌，客户端提供的令牌（任务 ID）都是唯一的。 如果客户端传入的令牌不唯一，`CalculatePrimeAsync` 会抛出异常。 如果唯一，令牌会被添加到任务 ID 集合中。

   C#复制

   ```csharp
   // This method starts an asynchronous calculation.
   // First, it checks the supplied task ID for uniqueness.
   // If taskId is unique, it creates a new WorkerEventHandler
   // and calls its BeginInvoke method to start the calculation.
   public virtual void CalculatePrimeAsync(
       int numberToTest,
       object taskId)
   {
       // Create an AsyncOperation for taskId.
       AsyncOperation asyncOp =
           AsyncOperationManager.CreateOperation(taskId);
   
       // Multiple threads will access the task dictionary,
       // so it must be locked to serialize access.
       lock (userStateToLifetime.SyncRoot)
       {
           if (userStateToLifetime.Contains(taskId))
           {
               throw new ArgumentException(
                   "Task ID parameter must be unique",
                   "taskId");
           }
   
           userStateToLifetime[taskId] = asyncOp;
       }
   
       // Start the asynchronous operation.
       WorkerEventHandler workerDelegate = new WorkerEventHandler(CalculateWorker);
       workerDelegate.BeginInvoke(
           numberToTest,
           asyncOp,
           null,
           null);
   }
   ```

2. 实现 `CancelAsync` 方法。 如果令牌集合中有 `taskId` 参数，将会删除此参数。 这可以防止尚未启动的已取消任务运行。 如果任务正在运行，`BuildPrimeNumberList` 方法会在检测到任务 ID 已从生存期集合中删除时退出。

   C#复制

   ```csharp
   // This method cancels a pending asynchronous operation.
   public void CancelAsync(object taskId)
   {
       AsyncOperation asyncOp = userStateToLifetime[taskId] as AsyncOperation;
       if (asyncOp != null)
       {
           lock (userStateToLifetime.SyncRoot)
           {
               userStateToLifetime.Remove(taskId);
           }
       }
   }
   ```



### 检查点 4

此时，可以生成组件。



#### 测试组件的具体步骤

- 编译组件。

`PrimeNumberCalculator` 组件现已完成且可供使用。

有关使用 `PrimeNumberCalculator` 组件的示例客户端，请参阅`PrimeNumberCalculator`。



### 后续步骤

可以编写与 `CalculatePrimeAsync` 方法相当的同步方法 `CalculatePrime`，扩充此示例。 这样一来，`PrimeNumberCalculator` 组件就完全符合基于事件的异步模式了。

若要改进此示例，可以保留对不同测试数字执行各种调用时发现的所有质数列表。 使用这种方法，所有任务都将受益于前面完成的任务。 请使用 `lock` 区域小心保护此列表，以序列化不同线程对列表的访问。

还可以测试是否有最简单的除数（如 2、3 和 5）来改进此示例。





## 如何：实现基于事件的异步模式的客户端

